// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseUpdate {
    #[prost(string, tag = "1")]
    pub rev: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseDelete {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub rev: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqUpload {
    #[prost(message, optional, tag = "1")]
    pub file: ::core::option::Option<EFileDocument>,
    #[prost(bytes = "vec", tag = "2")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqAppend {
    #[prost(message, optional, tag = "1")]
    pub file: ::core::option::Option<EFileDocument>,
    #[prost(bytes = "vec", tag = "2")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqDownload {
    #[prost(string, tag = "1")]
    pub file_document_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespUpload {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<EFileDocument>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespAppend {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<EFileDocument>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespDownload {
    #[prost(bytes = "vec", tag = "1")]
    pub result: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqUploadTable {
    #[prost(message, optional, tag = "1")]
    pub file: ::core::option::Option<EFileDocument>,
    #[prost(bytes = "vec", tag = "2")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqStreamTable {
    #[prost(string, tag = "1")]
    pub table_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub cnames: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "3")]
    pub offset: i64,
    #[prost(int64, tag = "4")]
    pub limit: i64,
    #[prost(string, tag = "5")]
    pub binary_format: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespUploadTable {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<ESchema>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespStreamTable {
    #[prost(bytes = "vec", tag = "1")]
    pub result: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqRunTask {
    #[prost(string, tag = "1")]
    pub task_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqCancelTask {
    #[prost(string, tag = "1")]
    pub task_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqWaitDone {
    #[prost(string, tag = "1")]
    pub task_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespRunTask {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespCancelTask {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespWaitDone {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<ETask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqGetCubeQuery {
    #[prost(string, tag = "1")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub step_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespGetCubeQuery {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<CubeQuery>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqConnect {
    #[prost(string, tag = "1")]
    pub username_or_email: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqConnect2 {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub username_or_email: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub password: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqGetServerVersion {
    #[prost(string, tag = "1")]
    pub module: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespConnect {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<UserSession>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespConnect2 {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<UserSession>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespGetServerVersion {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<Version>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EActivity {
    #[prost(oneof = "e_activity::Object", tags = "4")]
    pub object: ::core::option::Option<e_activity::Object>,
}
/// Nested message and enum types in `EActivity`.
pub mod e_activity {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "4")]
        Activity(super::Activity),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EcValues {
    #[prost(oneof = "ec_values::Object", tags = "161, 164, 163, 162")]
    pub object: ::core::option::Option<ec_values::Object>,
}
/// Nested message and enum types in `ECValues`.
pub mod ec_values {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "161")]
        Cvalues(super::CValues),
        #[prost(message, tag = "164")]
        F64values(super::F64Values),
        #[prost(message, tag = "163")]
        I32values(super::I32Values),
        #[prost(message, tag = "162")]
        Strvalues(super::StrValues),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EChart {
    #[prost(oneof = "e_chart::Object", tags = "7, 8, 9, 11, 12, 10")]
    pub object: ::core::option::Option<e_chart::Object>,
}
/// Nested message and enum types in `EChart`.
pub mod e_chart {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "7")]
        Chart(super::Chart),
        #[prost(message, tag = "8")]
        Chartbar(super::ChartBar),
        #[prost(message, tag = "9")]
        Chartheatmap(super::ChartHeatmap),
        #[prost(message, tag = "11")]
        Chartline(super::ChartLine),
        #[prost(message, tag = "12")]
        Chartpoint(super::ChartPoint),
        #[prost(message, tag = "10")]
        Chartsize(super::ChartSize),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EColumnSchema {
    #[prost(oneof = "e_column_schema::Object", tags = "160, 165")]
    pub object: ::core::option::Option<e_column_schema::Object>,
}
/// Nested message and enum types in `EColumnSchema`.
pub mod e_column_schema {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "160")]
        Column(super::Column),
        #[prost(message, tag = "165")]
        Columnschema(super::ColumnSchema),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EDocument {
    #[prost(
        oneof = "e_document::Object",
        tags = "170, 169, 60, 63, 26, 42, 28, 59, 57, 89, 27, 17, 61, 18, 240, 167, 64, 228, 168, 223, 222, 62, 185, 235"
    )]
    pub object: ::core::option::Option<e_document::Object>,
}
/// Nested message and enum types in `EDocument`.
pub mod e_document {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "170")]
        Computedtableschema(super::ComputedTableSchema),
        #[prost(message, tag = "169")]
        Cubequerytableschema(super::CubeQueryTableSchema),
        #[prost(message, tag = "60")]
        Dockeroperator(super::DockerOperator),
        #[prost(message, tag = "63")]
        Dockerwebappoperator(super::DockerWebAppOperator),
        #[prost(message, tag = "26")]
        Document(super::Document),
        #[prost(message, tag = "42")]
        Filedocument(super::FileDocument),
        #[prost(message, tag = "28")]
        Folderdocument(super::FolderDocument),
        #[prost(message, tag = "59")]
        Gitoperator(super::GitOperator),
        #[prost(message, tag = "57")]
        Operator(super::Operator),
        #[prost(message, tag = "89")]
        Project(super::Project),
        #[prost(message, tag = "27")]
        Projectdocument(super::ProjectDocument),
        #[prost(message, tag = "17")]
        Rlibrary(super::RLibrary),
        #[prost(message, tag = "61")]
        Roperator(super::ROperator),
        #[prost(message, tag = "18")]
        Rsourcelibrary(super::RSourceLibrary),
        #[prost(message, tag = "240")]
        Renvinstalledlibrary(super::RenvInstalledLibrary),
        #[prost(message, tag = "167")]
        Schema(super::Schema),
        #[prost(message, tag = "64")]
        Shinyoperator(super::ShinyOperator),
        #[prost(message, tag = "228")]
        Subscriptionplan(super::SubscriptionPlan),
        #[prost(message, tag = "168")]
        Tableschema(super::TableSchema),
        #[prost(message, tag = "223")]
        Team(super::Team),
        #[prost(message, tag = "222")]
        User(super::User),
        #[prost(message, tag = "62")]
        Webappoperator(super::WebAppOperator),
        #[prost(message, tag = "185")]
        Workerendpoint(super::WorkerEndpoint),
        #[prost(message, tag = "235")]
        Workflow(super::Workflow),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EEvent {
    #[prost(oneof = "e_event::Object", tags = "32, 35, 33, 38, 36, 39, 40, 37")]
    pub object: ::core::option::Option<e_event::Object>,
}
/// Nested message and enum types in `EEvent`.
pub mod e_event {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "32")]
        Event(super::Event),
        #[prost(message, tag = "35")]
        Genericevent(super::GenericEvent),
        #[prost(message, tag = "33")]
        Patchrecords(super::PatchRecords),
        #[prost(message, tag = "38")]
        Taskdataevent(super::TaskDataEvent),
        #[prost(message, tag = "36")]
        Taskevent(super::TaskEvent),
        #[prost(message, tag = "39")]
        Tasklogevent(super::TaskLogEvent),
        #[prost(message, tag = "40")]
        Taskprogressevent(super::TaskProgressEvent),
        #[prost(message, tag = "37")]
        Taskstateevent(super::TaskStateEvent),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EFileDocument {
    #[prost(oneof = "e_file_document::Object", tags = "42")]
    pub object: ::core::option::Option<e_file_document::Object>,
}
/// Nested message and enum types in `EFileDocument`.
pub mod e_file_document {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "42")]
        Filedocument(super::FileDocument),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EFileMetadata {
    #[prost(oneof = "e_file_metadata::Object", tags = "44, 43")]
    pub object: ::core::option::Option<e_file_metadata::Object>,
}
/// Nested message and enum types in `EFileMetadata`.
pub mod e_file_metadata {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "44")]
        Csvfilemetadata(super::CsvFileMetadata),
        #[prost(message, tag = "43")]
        Filemetadata(super::FileMetadata),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EFilterTopExpr {
    #[prost(oneof = "e_filter_top_expr::Object", tags = "46, 48, 49, 45, 47")]
    pub object: ::core::option::Option<e_filter_top_expr::Object>,
}
/// Nested message and enum types in `EFilterTopExpr`.
pub mod e_filter_top_expr {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "46")]
        Filter(super::Filter),
        #[prost(message, tag = "48")]
        Filterexpr(super::FilterExpr),
        #[prost(message, tag = "49")]
        Filterexpr2d(super::FilterExpr2d),
        #[prost(message, tag = "45")]
        Filtertopexpr(super::FilterTopExpr),
        #[prost(message, tag = "47")]
        Namedfilter(super::NamedFilter),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EFolderDocument {
    #[prost(oneof = "e_folder_document::Object", tags = "28")]
    pub object: ::core::option::Option<e_folder_document::Object>,
}
/// Nested message and enum types in `EFolderDocument`.
pub mod e_folder_document {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "28")]
        Folderdocument(super::FolderDocument),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EGarbageObject {
    #[prost(oneof = "e_garbage_object::Object", tags = "2196, 2197, 2198")]
    pub object: ::core::option::Option<e_garbage_object::Object>,
}
/// Nested message and enum types in `EGarbageObject`.
pub mod e_garbage_object {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "2196")]
        Garbageobject(super::GarbageObject),
        #[prost(message, tag = "2197")]
        Garbagetasks(super::GarbageTasks),
        #[prost(message, tag = "2198")]
        Garbagetasks2(super::GarbageTasks2),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ELock {
    #[prost(oneof = "e_lock::Object", tags = "1887")]
    pub object: ::core::option::Option<e_lock::Object>,
}
/// Nested message and enum types in `ELock`.
pub mod e_lock {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1887")]
        Lock(super::Lock),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EMetaFactor {
    #[prost(oneof = "e_meta_factor::Object", tags = "138, 139")]
    pub object: ::core::option::Option<e_meta_factor::Object>,
}
/// Nested message and enum types in `EMetaFactor`.
pub mod e_meta_factor {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "138")]
        Mappingfactor(super::MappingFactor),
        #[prost(message, tag = "139")]
        Metafactor(super::MetaFactor),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EOperator {
    #[prost(oneof = "e_operator::Object", tags = "60, 63, 59, 57, 61, 64, 62")]
    pub object: ::core::option::Option<e_operator::Object>,
}
/// Nested message and enum types in `EOperator`.
pub mod e_operator {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "60")]
        Dockeroperator(super::DockerOperator),
        #[prost(message, tag = "63")]
        Dockerwebappoperator(super::DockerWebAppOperator),
        #[prost(message, tag = "59")]
        Gitoperator(super::GitOperator),
        #[prost(message, tag = "57")]
        Operator(super::Operator),
        #[prost(message, tag = "61")]
        Roperator(super::ROperator),
        #[prost(message, tag = "64")]
        Shinyoperator(super::ShinyOperator),
        #[prost(message, tag = "62")]
        Webappoperator(super::WebAppOperator),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EOperatorInputSpec {
    #[prost(oneof = "e_operator_input_spec::Object", tags = "136, 134")]
    pub object: ::core::option::Option<e_operator_input_spec::Object>,
}
/// Nested message and enum types in `EOperatorInputSpec`.
pub mod e_operator_input_spec {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "136")]
        Crosstabspec(super::CrosstabSpec),
        #[prost(message, tag = "134")]
        Operatorinputspec(super::OperatorInputSpec),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EOperatorModel {
    #[prost(oneof = "e_operator_model::Object", tags = "153, 150, 152")]
    pub object: ::core::option::Option<e_operator_model::Object>,
}
/// Nested message and enum types in `EOperatorModel`.
pub mod e_operator_model {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "153")]
        Annotationoperatormodel(super::AnnotationOperatorModel),
        #[prost(message, tag = "150")]
        Gateoperatormodel(super::GateOperatorModel),
        #[prost(message, tag = "152")]
        Operatormodel(super::OperatorModel),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EPalette {
    #[prost(oneof = "e_palette::Object", tags = "72, 71, 69, 70")]
    pub object: ::core::option::Option<e_palette::Object>,
}
/// Nested message and enum types in `EPalette`.
pub mod e_palette {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "72")]
        Categorypalette(super::CategoryPalette),
        #[prost(message, tag = "71")]
        Jetpalette(super::JetPalette),
        #[prost(message, tag = "69")]
        Palette(super::Palette),
        #[prost(message, tag = "70")]
        Ramppalette(super::RampPalette),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EPatchRecords {
    #[prost(oneof = "e_patch_records::Object", tags = "33")]
    pub object: ::core::option::Option<e_patch_records::Object>,
}
/// Nested message and enum types in `EPatchRecords`.
pub mod e_patch_records {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "33")]
        Patchrecords(super::PatchRecords),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EPersistentObject {
    #[prost(
        oneof = "e_persistent_object::Object",
        tags = "4, 212, 215, 170, 202, 169, 214, 60, 63, 26, 32, 205, 207, 42, 28, 2196, 2197, 2198, 35, 59, 200, 218, 210, 209, 208, 201, 1887, 57, 33, 74, 89, 27, 204, 17, 61, 18, 240, 216, 211, 206, 217, 167, 64, 228, 168, 2199, 38, 36, 39, 40, 37, 223, 203, 222, 224, 62, 185, 235"
    )]
    pub object: ::core::option::Option<e_persistent_object::Object>,
}
/// Nested message and enum types in `EPersistentObject`.
pub mod e_persistent_object {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "4")]
        Activity(super::Activity),
        #[prost(message, tag = "212")]
        Csvtask(super::CsvTask),
        #[prost(message, tag = "215")]
        Computationtask(super::ComputationTask),
        #[prost(message, tag = "170")]
        Computedtableschema(super::ComputedTableSchema),
        #[prost(message, tag = "202")]
        Creategitoperatortask(super::CreateGitOperatorTask),
        #[prost(message, tag = "169")]
        Cubequerytableschema(super::CubeQueryTableSchema),
        #[prost(message, tag = "214")]
        Cubequerytask(super::CubeQueryTask),
        #[prost(message, tag = "60")]
        Dockeroperator(super::DockerOperator),
        #[prost(message, tag = "63")]
        Dockerwebappoperator(super::DockerWebAppOperator),
        #[prost(message, tag = "26")]
        Document(super::Document),
        #[prost(message, tag = "32")]
        Event(super::Event),
        #[prost(message, tag = "205")]
        Exporttabletask(super::ExportTableTask),
        #[prost(message, tag = "207")]
        Exportworkflowtask(super::ExportWorkflowTask),
        #[prost(message, tag = "42")]
        Filedocument(super::FileDocument),
        #[prost(message, tag = "28")]
        Folderdocument(super::FolderDocument),
        #[prost(message, tag = "2196")]
        Garbageobject(super::GarbageObject),
        #[prost(message, tag = "2197")]
        Garbagetasks(super::GarbageTasks),
        #[prost(message, tag = "2198")]
        Garbagetasks2(super::GarbageTasks2),
        #[prost(message, tag = "35")]
        Genericevent(super::GenericEvent),
        #[prost(message, tag = "59")]
        Gitoperator(super::GitOperator),
        #[prost(message, tag = "200")]
        Gitprojecttask(super::GitProjectTask),
        #[prost(message, tag = "218")]
        Gltask(super::GlTask),
        #[prost(message, tag = "210")]
        Importgitdatasettask(super::ImportGitDatasetTask),
        #[prost(message, tag = "209")]
        Importgitworkflowtask(super::ImportGitWorkflowTask),
        #[prost(message, tag = "208")]
        Importworkflowtask(super::ImportWorkflowTask),
        #[prost(message, tag = "201")]
        Librarytask(super::LibraryTask),
        #[prost(message, tag = "1887")]
        Lock(super::Lock),
        #[prost(message, tag = "57")]
        Operator(super::Operator),
        #[prost(message, tag = "33")]
        Patchrecords(super::PatchRecords),
        #[prost(message, tag = "74")]
        Persistentobject(super::PersistentObject),
        #[prost(message, tag = "89")]
        Project(super::Project),
        #[prost(message, tag = "27")]
        Projectdocument(super::ProjectDocument),
        #[prost(message, tag = "204")]
        Projecttask(super::ProjectTask),
        #[prost(message, tag = "17")]
        Rlibrary(super::RLibrary),
        #[prost(message, tag = "61")]
        Roperator(super::ROperator),
        #[prost(message, tag = "18")]
        Rsourcelibrary(super::RSourceLibrary),
        #[prost(message, tag = "240")]
        Renvinstalledlibrary(super::RenvInstalledLibrary),
        #[prost(message, tag = "216")]
        Runcomputationtask(super::RunComputationTask),
        #[prost(message, tag = "211")]
        Runwebapptask(super::RunWebAppTask),
        #[prost(message, tag = "206")]
        Runworkflowtask(super::RunWorkflowTask),
        #[prost(message, tag = "217")]
        Savecomputationresulttask(super::SaveComputationResultTask),
        #[prost(message, tag = "167")]
        Schema(super::Schema),
        #[prost(message, tag = "64")]
        Shinyoperator(super::ShinyOperator),
        #[prost(message, tag = "228")]
        Subscriptionplan(super::SubscriptionPlan),
        #[prost(message, tag = "168")]
        Tableschema(super::TableSchema),
        #[prost(message, tag = "2199")]
        Task(super::Task),
        #[prost(message, tag = "38")]
        Taskdataevent(super::TaskDataEvent),
        #[prost(message, tag = "36")]
        Taskevent(super::TaskEvent),
        #[prost(message, tag = "39")]
        Tasklogevent(super::TaskLogEvent),
        #[prost(message, tag = "40")]
        Taskprogressevent(super::TaskProgressEvent),
        #[prost(message, tag = "37")]
        Taskstateevent(super::TaskStateEvent),
        #[prost(message, tag = "223")]
        Team(super::Team),
        #[prost(message, tag = "203")]
        Testoperatortask(super::TestOperatorTask),
        #[prost(message, tag = "222")]
        User(super::User),
        #[prost(message, tag = "224")]
        Usersecret(super::UserSecret),
        #[prost(message, tag = "62")]
        Webappoperator(super::WebAppOperator),
        #[prost(message, tag = "185")]
        Workerendpoint(super::WorkerEndpoint),
        #[prost(message, tag = "235")]
        Workflow(super::Workflow),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EProject {
    #[prost(oneof = "e_project::Object", tags = "89")]
    pub object: ::core::option::Option<e_project::Object>,
}
/// Nested message and enum types in `EProject`.
pub mod e_project {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "89")]
        Project(super::Project),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EProjectDocument {
    #[prost(
        oneof = "e_project_document::Object",
        tags = "170, 169, 42, 28, 27, 167, 168, 235"
    )]
    pub object: ::core::option::Option<e_project_document::Object>,
}
/// Nested message and enum types in `EProjectDocument`.
pub mod e_project_document {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "170")]
        Computedtableschema(super::ComputedTableSchema),
        #[prost(message, tag = "169")]
        Cubequerytableschema(super::CubeQueryTableSchema),
        #[prost(message, tag = "42")]
        Filedocument(super::FileDocument),
        #[prost(message, tag = "28")]
        Folderdocument(super::FolderDocument),
        #[prost(message, tag = "27")]
        Projectdocument(super::ProjectDocument),
        #[prost(message, tag = "167")]
        Schema(super::Schema),
        #[prost(message, tag = "168")]
        Tableschema(super::TableSchema),
        #[prost(message, tag = "235")]
        Workflow(super::Workflow),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EProperty {
    #[prost(oneof = "e_property::Object", tags = "96, 95, 94, 93, 92, 90, 91")]
    pub object: ::core::option::Option<e_property::Object>,
}
/// Nested message and enum types in `EProperty`.
pub mod e_property {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "96")]
        Booleanproperty(super::BooleanProperty),
        #[prost(message, tag = "95")]
        Doubleproperty(super::DoubleProperty),
        #[prost(message, tag = "94")]
        Enumeratedproperty(super::EnumeratedProperty),
        #[prost(message, tag = "93")]
        Factorsproperty(super::FactorsProperty),
        #[prost(message, tag = "92")]
        Formulaproperty(super::FormulaProperty),
        #[prost(message, tag = "90")]
        Property(super::Property),
        #[prost(message, tag = "91")]
        Stringproperty(super::StringProperty),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErLibrary {
    #[prost(oneof = "er_library::Object", tags = "17, 18, 240")]
    pub object: ::core::option::Option<er_library::Object>,
}
/// Nested message and enum types in `ERLibrary`.
pub mod er_library {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "17")]
        Rlibrary(super::RLibrary),
        #[prost(message, tag = "18")]
        Rsourcelibrary(super::RSourceLibrary),
        #[prost(message, tag = "240")]
        Renvinstalledlibrary(super::RenvInstalledLibrary),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ERelation {
    #[prost(
        oneof = "e_relation::Object",
        tags = "108, 112, 109, 111, 113, 114, 104, 105, 101, 107, 115, 102, 103, 106, 110"
    )]
    pub object: ::core::option::Option<e_relation::Object>,
}
/// Nested message and enum types in `ERelation`.
pub mod e_relation {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "108")]
        Compositerelation(::prost::alloc::boxed::Box<super::CompositeRelation>),
        #[prost(message, tag = "112")]
        Distinctrelation(::prost::alloc::boxed::Box<super::DistinctRelation>),
        #[prost(message, tag = "109")]
        Gatherrelation(::prost::alloc::boxed::Box<super::GatherRelation>),
        #[prost(message, tag = "111")]
        Groupbyrelation(::prost::alloc::boxed::Box<super::GroupByRelation>),
        #[prost(message, tag = "113")]
        Inmemoryrelation(super::InMemoryRelation),
        #[prost(message, tag = "114")]
        Pairwiserelation(::prost::alloc::boxed::Box<super::PairwiseRelation>),
        #[prost(message, tag = "104")]
        Rangerelation(::prost::alloc::boxed::Box<super::RangeRelation>),
        #[prost(message, tag = "105")]
        Referencerelation(::prost::alloc::boxed::Box<super::ReferenceRelation>),
        #[prost(message, tag = "101")]
        Relation(super::Relation),
        #[prost(message, tag = "107")]
        Renamerelation(::prost::alloc::boxed::Box<super::RenameRelation>),
        #[prost(message, tag = "115")]
        Selectpairwiserelation(
            ::prost::alloc::boxed::Box<super::SelectPairwiseRelation>,
        ),
        #[prost(message, tag = "102")]
        Simplerelation(super::SimpleRelation),
        #[prost(message, tag = "103")]
        Tablerelation(super::TableRelation),
        #[prost(message, tag = "106")]
        Unionrelation(super::UnionRelation),
        #[prost(message, tag = "110")]
        Whererelation(::prost::alloc::boxed::Box<super::WhereRelation>),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ESchema {
    #[prost(oneof = "e_schema::Object", tags = "170, 169, 167, 168")]
    pub object: ::core::option::Option<e_schema::Object>,
}
/// Nested message and enum types in `ESchema`.
pub mod e_schema {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "170")]
        Computedtableschema(super::ComputedTableSchema),
        #[prost(message, tag = "169")]
        Cubequerytableschema(super::CubeQueryTableSchema),
        #[prost(message, tag = "167")]
        Schema(super::Schema),
        #[prost(message, tag = "168")]
        Tableschema(super::TableSchema),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EState {
    #[prost(
        oneof = "e_state::Object",
        tags = "2195, 2193, 2194, 189, 2191, 2190, 2192, 188"
    )]
    pub object: ::core::option::Option<e_state::Object>,
}
/// Nested message and enum types in `EState`.
pub mod e_state {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "2195")]
        Canceledstate(super::CanceledState),
        #[prost(message, tag = "2193")]
        Donestate(super::DoneState),
        #[prost(message, tag = "2194")]
        Failedstate(super::FailedState),
        #[prost(message, tag = "189")]
        Initstate(super::InitState),
        #[prost(message, tag = "2191")]
        Pendingstate(super::PendingState),
        #[prost(message, tag = "2190")]
        Runningdependentstate(super::RunningDependentState),
        #[prost(message, tag = "2192")]
        Runningstate(super::RunningState),
        #[prost(message, tag = "188")]
        State(super::State),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EStep {
    #[prost(
        oneof = "e_step::Object",
        tags = "155, 147, 122, 146, 125, 144, 141, 120, 143, 126, 124, 118, 127, 129, 130"
    )]
    pub object: ::core::option::Option<e_step::Object>,
}
/// Nested message and enum types in `EStep`.
pub mod e_step {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "155")]
        Crosstabstep(super::CrossTabStep),
        #[prost(message, tag = "147")]
        Datastep(super::DataStep),
        #[prost(message, tag = "122")]
        Exportstep(super::ExportStep),
        #[prost(message, tag = "146")]
        Groupstep(super::GroupStep),
        #[prost(message, tag = "125")]
        Instep(super::InStep),
        #[prost(message, tag = "144")]
        Joinstep(super::JoinStep),
        #[prost(message, tag = "141")]
        Meltstep(super::MeltStep),
        #[prost(message, tag = "120")]
        Modelstep(super::ModelStep),
        #[prost(message, tag = "143")]
        Namespacestep(super::NamespaceStep),
        #[prost(message, tag = "126")]
        Outstep(super::OutStep),
        #[prost(message, tag = "124")]
        Relationstep(super::RelationStep),
        #[prost(message, tag = "118")]
        Step(super::Step),
        #[prost(message, tag = "127")]
        Tablestep(super::TableStep),
        #[prost(message, tag = "129")]
        Viewstep(super::ViewStep),
        #[prost(message, tag = "130")]
        Wizardstep(super::WizardStep),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ESubscriptionPlan {
    #[prost(oneof = "e_subscription_plan::Object", tags = "228")]
    pub object: ::core::option::Option<e_subscription_plan::Object>,
}
/// Nested message and enum types in `ESubscriptionPlan`.
pub mod e_subscription_plan {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "228")]
        Subscriptionplan(super::SubscriptionPlan),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ETask {
    #[prost(
        oneof = "e_task::Object",
        tags = "212, 215, 202, 214, 205, 207, 200, 218, 210, 209, 208, 201, 204, 216, 211, 206, 217, 2199, 203"
    )]
    pub object: ::core::option::Option<e_task::Object>,
}
/// Nested message and enum types in `ETask`.
pub mod e_task {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "212")]
        Csvtask(super::CsvTask),
        #[prost(message, tag = "215")]
        Computationtask(super::ComputationTask),
        #[prost(message, tag = "202")]
        Creategitoperatortask(super::CreateGitOperatorTask),
        #[prost(message, tag = "214")]
        Cubequerytask(super::CubeQueryTask),
        #[prost(message, tag = "205")]
        Exporttabletask(super::ExportTableTask),
        #[prost(message, tag = "207")]
        Exportworkflowtask(super::ExportWorkflowTask),
        #[prost(message, tag = "200")]
        Gitprojecttask(super::GitProjectTask),
        #[prost(message, tag = "218")]
        Gltask(super::GlTask),
        #[prost(message, tag = "210")]
        Importgitdatasettask(super::ImportGitDatasetTask),
        #[prost(message, tag = "209")]
        Importgitworkflowtask(super::ImportGitWorkflowTask),
        #[prost(message, tag = "208")]
        Importworkflowtask(super::ImportWorkflowTask),
        #[prost(message, tag = "201")]
        Librarytask(super::LibraryTask),
        #[prost(message, tag = "204")]
        Projecttask(super::ProjectTask),
        #[prost(message, tag = "216")]
        Runcomputationtask(super::RunComputationTask),
        #[prost(message, tag = "211")]
        Runwebapptask(super::RunWebAppTask),
        #[prost(message, tag = "206")]
        Runworkflowtask(super::RunWorkflowTask),
        #[prost(message, tag = "217")]
        Savecomputationresulttask(super::SaveComputationResultTask),
        #[prost(message, tag = "2199")]
        Task(super::Task),
        #[prost(message, tag = "203")]
        Testoperatortask(super::TestOperatorTask),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ETeam {
    #[prost(oneof = "e_team::Object", tags = "223")]
    pub object: ::core::option::Option<e_team::Object>,
}
/// Nested message and enum types in `ETeam`.
pub mod e_team {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "223")]
        Team(super::Team),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EUser {
    #[prost(oneof = "e_user::Object", tags = "223, 222")]
    pub object: ::core::option::Option<e_user::Object>,
}
/// Nested message and enum types in `EUser`.
pub mod e_user {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "223")]
        Team(super::Team),
        #[prost(message, tag = "222")]
        User(super::User),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EUserSecret {
    #[prost(oneof = "e_user_secret::Object", tags = "224")]
    pub object: ::core::option::Option<e_user_secret::Object>,
}
/// Nested message and enum types in `EUserSecret`.
pub mod e_user_secret {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "224")]
        Usersecret(super::UserSecret),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EWorkflow {
    #[prost(oneof = "e_workflow::Object", tags = "235")]
    pub object: ::core::option::Option<e_workflow::Object>,
}
/// Nested message and enum types in `EWorkflow`.
pub mod e_workflow {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "235")]
        Workflow(super::Workflow),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ace {
    #[prost(message, repeated, tag = "1001")]
    pub principals: ::prost::alloc::vec::Vec<Principal>,
    #[prost(message, repeated, tag = "1002")]
    pub privileges: ::prost::alloc::vec::Vec<Privilege>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Acl {
    #[prost(string, tag = "2001")]
    pub owner: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2002")]
    pub aces: ::prost::alloc::vec::Vec<Ace>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AclContext {
    #[prost(string, tag = "3001")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "3002")]
    pub domain: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Activity {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4001")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "4002")]
    pub object_kind: ::prost::alloc::string::String,
    #[prost(string, tag = "4004")]
    pub team_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4005")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4006")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4007")]
    pub project_name: ::prost::alloc::string::String,
    #[prost(bool, tag = "4008")]
    pub is_public: bool,
    #[prost(message, optional, tag = "4003")]
    pub date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "4009")]
    pub properties: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityCount {
    #[prost(string, tag = "239001")]
    pub object_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "239002")]
    pub count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Address {
    #[prost(string, tag = "230001")]
    pub country: ::prost::alloc::string::String,
    #[prost(string, tag = "230002")]
    pub state: ::prost::alloc::string::String,
    #[prost(string, tag = "230003")]
    pub city: ::prost::alloc::string::String,
    #[prost(string, tag = "230004")]
    pub zip_code: ::prost::alloc::string::String,
    #[prost(string, tag = "230005")]
    pub address1: ::prost::alloc::string::String,
    #[prost(string, tag = "230006")]
    pub address2: ::prost::alloc::string::String,
    #[prost(string, tag = "230007")]
    pub phone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotationModel {
    #[prost(string, tag = "154004")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "154001")]
    pub factors: ::prost::alloc::vec::Vec<GraphicalFactor>,
    #[prost(message, repeated, tag = "154002")]
    pub annotation_factors: ::prost::alloc::vec::Vec<GraphicalFactor>,
    #[prost(message, optional, tag = "154003")]
    pub relation: ::core::option::Option<ERelation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotationOperatorModel {
    #[prost(message, optional, tag = "153001")]
    pub filters: ::core::option::Option<Filters>,
    #[prost(message, repeated, tag = "153002")]
    pub annotation_models: ::prost::alloc::vec::Vec<AnnotationModel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiCallProfile {
    #[prost(string, tag = "80001")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "85001")]
    pub n_calls: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppDesign {
    #[prost(string, tag = "132001")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "132002")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "132003")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "132004")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "132005")]
    pub factors: ::prost::alloc::vec::Vec<MappingFactor>,
    #[prost(message, repeated, tag = "132006")]
    pub filters: ::prost::alloc::vec::Vec<MappingFilter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Attribute {
    #[prost(string, tag = "41001")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "41002")]
    pub r#type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Axis {
    #[prost(message, optional, tag = "6001")]
    pub axis_extent: ::core::option::Option<Point>,
    #[prost(message, optional, tag = "6002")]
    pub axis_settings: ::core::option::Option<AxisSettings>,
    #[prost(message, optional, tag = "6003")]
    pub graphical_factor: ::core::option::Option<GraphicalFactor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AxisSettings {
    #[prost(message, repeated, tag = "5001")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AxisSpec {
    #[prost(message, repeated, tag = "137001")]
    pub meta_factors: ::prost::alloc::vec::Vec<EMetaFactor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BillingInfo {
    #[prost(string, tag = "231001")]
    pub first_name: ::prost::alloc::string::String,
    #[prost(string, tag = "231002")]
    pub last_name: ::prost::alloc::string::String,
    #[prost(string, tag = "231003")]
    pub company_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "231004")]
    pub tax_id: ::core::option::Option<TaxId>,
    #[prost(message, optional, tag = "231005")]
    pub address: ::core::option::Option<Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BooleanProperty {
    #[prost(string, tag = "90001")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "90002")]
    pub description: ::prost::alloc::string::String,
    #[prost(bool, tag = "96001")]
    pub default_value: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvFileMetadata {
    #[prost(string, tag = "43001")]
    pub content_type: ::prost::alloc::string::String,
    #[prost(string, tag = "43002")]
    pub cache_control: ::prost::alloc::string::String,
    #[prost(string, tag = "43003")]
    pub content_encoding: ::prost::alloc::string::String,
    #[prost(string, tag = "43004")]
    pub content_language: ::prost::alloc::string::String,
    #[prost(string, tag = "43005")]
    pub md5_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "44001")]
    pub separator: ::prost::alloc::string::String,
    #[prost(string, tag = "44002")]
    pub quote: ::prost::alloc::string::String,
    #[prost(bool, tag = "44003")]
    pub headers: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvParserParam {
    #[prost(string, tag = "213001")]
    pub separator: ::prost::alloc::string::String,
    #[prost(string, tag = "213002")]
    pub encoding: ::prost::alloc::string::String,
    #[prost(string, tag = "213003")]
    pub quote: ::prost::alloc::string::String,
    #[prost(bool, tag = "213004")]
    pub has_headers: bool,
    #[prost(bool, tag = "213005")]
    pub allow_malformed: bool,
    #[prost(string, tag = "213006")]
    pub comment: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvTask {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "2199007")]
    pub duration: f64,
    #[prost(string, tag = "2199009")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2199010")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2199011")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2199012")]
    pub size: i32,
    #[prost(string, tag = "204001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "212001")]
    pub file_document_id: ::prost::alloc::string::String,
    #[prost(string, tag = "212002")]
    pub schema_id: ::prost::alloc::string::String,
    #[prost(string, tag = "212003")]
    pub value_name: ::prost::alloc::string::String,
    #[prost(string, tag = "212004")]
    pub variable_name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "212005")]
    pub gather_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2199001")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "2199002")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "2199003")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199004")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199005")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199006")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199008")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "2199013")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "212006")]
    pub schema: ::core::option::Option<ESchema>,
    #[prost(message, optional, tag = "212007")]
    pub params: ::core::option::Option<CsvParserParam>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CValues {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CanceledState {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CategoryPalette {
    #[prost(int32, tag = "69001")]
    pub backcolor: i32,
    #[prost(message, repeated, tag = "69002")]
    pub properties: ::prost::alloc::vec::Vec<PropertyValue>,
    #[prost(message, optional, tag = "72001")]
    pub color_list: ::core::option::Option<ColorList>,
    #[prost(message, repeated, tag = "72002")]
    pub string_color_elements: ::prost::alloc::vec::Vec<StringColorElement>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Chart {
    #[prost(string, tag = "7001")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7002")]
    pub properties: ::core::option::Option<Properties>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChartBar {
    #[prost(string, tag = "7001")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7002")]
    pub properties: ::core::option::Option<Properties>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChartHeatmap {
    #[prost(string, tag = "7001")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7002")]
    pub properties: ::core::option::Option<Properties>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChartLine {
    #[prost(string, tag = "7001")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "10001")]
    pub point_size: i32,
    #[prost(message, optional, tag = "7002")]
    pub properties: ::core::option::Option<Properties>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChartPoint {
    #[prost(string, tag = "7001")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "10001")]
    pub point_size: i32,
    #[prost(message, optional, tag = "7002")]
    pub properties: ::core::option::Option<Properties>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChartSize {
    #[prost(string, tag = "7001")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "10001")]
    pub point_size: i32,
    #[prost(message, optional, tag = "7002")]
    pub properties: ::core::option::Option<Properties>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColorElement {
    #[prost(int32, tag = "13001")]
    pub color: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColorList {
    #[prost(string, tag = "14001")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Colors {
    #[prost(message, repeated, tag = "15001")]
    pub factors: ::prost::alloc::vec::Vec<Factor>,
    #[prost(message, optional, tag = "15002")]
    pub palette: ::core::option::Option<EPalette>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Column {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "165001")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "165002")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(int32, tag = "165003")]
    pub n_rows: i32,
    #[prost(int32, tag = "165004")]
    pub size: i32,
    #[prost(bytes = "vec", tag = "160002")]
    pub values: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "165005")]
    pub meta_data: ::core::option::Option<ColumnSchemaMetaData>,
    #[prost(message, optional, tag = "160001")]
    pub c_values: ::core::option::Option<EcValues>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnPair {
    #[prost(string, repeated, tag = "117001")]
    pub l_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "117002")]
    pub r_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnSchema {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "165001")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "165002")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(int32, tag = "165003")]
    pub n_rows: i32,
    #[prost(int32, tag = "165004")]
    pub size: i32,
    #[prost(message, optional, tag = "165005")]
    pub meta_data: ::core::option::Option<ColumnSchemaMetaData>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnSchemaMetaData {
    #[prost(string, repeated, tag = "166001")]
    pub sort: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "166002")]
    pub ascending: bool,
    #[prost(string, repeated, tag = "166003")]
    pub quartiles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "166004")]
    pub properties: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompositeRelation {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "108001")]
    pub join_operators: ::prost::alloc::vec::Vec<JoinOperator>,
    #[prost(message, optional, boxed, tag = "108002")]
    pub main_relation: ::core::option::Option<::prost::alloc::boxed::Box<ERelation>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputationTask {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "2199007")]
    pub duration: f64,
    #[prost(string, tag = "2199009")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2199010")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2199011")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2199012")]
    pub size: i32,
    #[prost(string, tag = "204001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "214002")]
    pub remove_on_gc: bool,
    #[prost(string, repeated, tag = "214003")]
    pub schema_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "215001")]
    pub parent_task_id: ::prost::alloc::string::String,
    #[prost(string, tag = "215002")]
    pub file_result_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2199001")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "2199002")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "2199003")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199004")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199005")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199006")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199008")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "2199013")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "214001")]
    pub query: ::core::option::Option<CubeQuery>,
    #[prost(message, optional, tag = "215003")]
    pub computed_relation: ::core::option::Option<ERelation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputedTableSchema {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(string, tag = "27001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "27002")]
    pub folder_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "167001")]
    pub n_rows: i32,
    #[prost(string, tag = "167003")]
    pub data_directory: ::prost::alloc::string::String,
    #[prost(int32, tag = "167005")]
    pub size: i32,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "167002")]
    pub columns: ::prost::alloc::vec::Vec<EColumnSchema>,
    #[prost(message, optional, tag = "167004")]
    pub relation: ::core::option::Option<ERelation>,
    #[prost(message, optional, tag = "170001")]
    pub query: ::core::option::Option<CubeQuery>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CpuTimeProfile {
    #[prost(string, tag = "80001")]
    pub name: ::prost::alloc::string::String,
    #[prost(double, tag = "83001")]
    pub cpu_time: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateGitOperatorTask {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "2199007")]
    pub duration: f64,
    #[prost(string, tag = "2199009")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2199010")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2199011")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2199012")]
    pub size: i32,
    #[prost(string, tag = "202002")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "202003")]
    pub operator_id: ::prost::alloc::string::String,
    #[prost(string, tag = "202004")]
    pub git_token: ::prost::alloc::string::String,
    #[prost(bool, tag = "202005")]
    pub test_required: bool,
    #[prost(message, repeated, tag = "2199001")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "2199002")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "2199003")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199004")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199005")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199006")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199008")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "2199013")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "202001")]
    pub url: ::core::option::Option<Url>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrossTabStep {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "118001")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "118002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "118007")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "118003")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "118004")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "118005")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "118006")]
    pub state: ::core::option::Option<StepState>,
    #[prost(message, optional, tag = "155001")]
    pub model: ::core::option::Option<Crosstab>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Crosstab {
    #[prost(string, tag = "156006")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "156001")]
    pub axis: ::core::option::Option<XyAxisList>,
    #[prost(message, optional, tag = "156002")]
    pub column_table: ::core::option::Option<CrosstabTable>,
    #[prost(message, optional, tag = "156003")]
    pub filters: ::core::option::Option<Filters>,
    #[prost(message, optional, tag = "156004")]
    pub operator_settings: ::core::option::Option<OperatorSettings>,
    #[prost(message, optional, tag = "156005")]
    pub row_table: ::core::option::Option<CrosstabTable>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrosstabSpec {
    #[prost(message, repeated, tag = "136001")]
    pub meta_factors: ::prost::alloc::vec::Vec<EMetaFactor>,
    #[prost(message, repeated, tag = "136002")]
    pub axis: ::prost::alloc::vec::Vec<AxisSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrosstabTable {
    #[prost(double, tag = "21001")]
    pub cell_size: f64,
    #[prost(int32, tag = "21002")]
    pub offset: i32,
    #[prost(int32, tag = "21005")]
    pub n_rows: i32,
    #[prost(message, repeated, tag = "21003")]
    pub graphical_factors: ::prost::alloc::vec::Vec<GraphicalFactor>,
    #[prost(message, repeated, tag = "21004")]
    pub rectangle_selections: ::prost::alloc::vec::Vec<Rectangle>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CubeAxisQuery {
    #[prost(int32, tag = "23001")]
    pub point_size: i32,
    #[prost(string, tag = "23002")]
    pub chart_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "23003")]
    pub y_axis: ::core::option::Option<Factor>,
    #[prost(message, optional, tag = "23004")]
    pub y_axis_settings: ::core::option::Option<AxisSettings>,
    #[prost(message, optional, tag = "23005")]
    pub x_axis: ::core::option::Option<Factor>,
    #[prost(message, optional, tag = "23006")]
    pub x_axis_settings: ::core::option::Option<AxisSettings>,
    #[prost(message, repeated, tag = "23007")]
    pub errors: ::prost::alloc::vec::Vec<Factor>,
    #[prost(message, repeated, tag = "23008")]
    pub labels: ::prost::alloc::vec::Vec<Factor>,
    #[prost(message, repeated, tag = "23009")]
    pub colors: ::prost::alloc::vec::Vec<Factor>,
    #[prost(message, repeated, tag = "23010")]
    pub preprocessors: ::prost::alloc::vec::Vec<PreProcessor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CubeQuery {
    #[prost(string, tag = "22007")]
    pub qt_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "22008")]
    pub column_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "22009")]
    pub row_hash: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "22001")]
    pub relation: ::core::option::Option<ERelation>,
    #[prost(message, repeated, tag = "22002")]
    pub col_columns: ::prost::alloc::vec::Vec<Factor>,
    #[prost(message, repeated, tag = "22003")]
    pub row_columns: ::prost::alloc::vec::Vec<Factor>,
    #[prost(message, repeated, tag = "22004")]
    pub axis_queries: ::prost::alloc::vec::Vec<CubeAxisQuery>,
    #[prost(message, optional, tag = "22005")]
    pub filters: ::core::option::Option<Filters>,
    #[prost(message, optional, tag = "22006")]
    pub operator_settings: ::core::option::Option<OperatorSettings>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CubeQueryTableSchema {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(string, tag = "27001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "27002")]
    pub folder_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "167001")]
    pub n_rows: i32,
    #[prost(string, tag = "167003")]
    pub data_directory: ::prost::alloc::string::String,
    #[prost(int32, tag = "167005")]
    pub size: i32,
    #[prost(string, tag = "169001")]
    pub query_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "169002")]
    pub query_table_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "167002")]
    pub columns: ::prost::alloc::vec::Vec<EColumnSchema>,
    #[prost(message, optional, tag = "167004")]
    pub relation: ::core::option::Option<ERelation>,
    #[prost(message, optional, tag = "169003")]
    pub query: ::core::option::Option<CubeQuery>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CubeQueryTask {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "2199007")]
    pub duration: f64,
    #[prost(string, tag = "2199009")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2199010")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2199011")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2199012")]
    pub size: i32,
    #[prost(string, tag = "204001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "214002")]
    pub remove_on_gc: bool,
    #[prost(string, repeated, tag = "214003")]
    pub schema_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2199001")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "2199002")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "2199003")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199004")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199005")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199006")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199008")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "2199013")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "214001")]
    pub query: ::core::option::Option<CubeQuery>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataStep {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "118001")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "118002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "118007")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "147002")]
    pub parent_data_step_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "118003")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "118004")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "118005")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "118006")]
    pub state: ::core::option::Option<StepState>,
    #[prost(message, optional, tag = "155001")]
    pub model: ::core::option::Option<Crosstab>,
    #[prost(message, optional, tag = "147001")]
    pub computed_relation: ::core::option::Option<ERelation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Date {
    #[prost(string, tag = "25001")]
    pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DistinctRelation {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "112002")]
    pub group: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, boxed, tag = "112001")]
    pub relation: ::core::option::Option<::prost::alloc::boxed::Box<ERelation>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DockerOperator {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(string, tag = "59001")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "60001")]
    pub container: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "57001")]
    pub properties: ::prost::alloc::vec::Vec<EProperty>,
    #[prost(message, optional, tag = "57002")]
    pub operator_spec: ::core::option::Option<OperatorSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DockerWebAppOperator {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(string, tag = "59001")]
    pub path: ::prost::alloc::string::String,
    #[prost(bool, tag = "62001")]
    pub is_view_only: bool,
    #[prost(string, tag = "62002")]
    pub entry_type: ::prost::alloc::string::String,
    #[prost(string, tag = "63001")]
    pub container: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "57001")]
    pub properties: ::prost::alloc::vec::Vec<EProperty>,
    #[prost(message, optional, tag = "57002")]
    pub operator_spec: ::core::option::Option<OperatorSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Document {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoneState {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoubleColorElement {
    #[prost(int32, tag = "13001")]
    pub color: i32,
    #[prost(string, tag = "30001")]
    pub string_value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoubleProperty {
    #[prost(string, tag = "90001")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "90002")]
    pub description: ::prost::alloc::string::String,
    #[prost(double, tag = "95001")]
    pub default_value: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumeratedProperty {
    #[prost(string, tag = "90001")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "90002")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "91001")]
    pub default_value: ::prost::alloc::string::String,
    #[prost(bool, tag = "94001")]
    pub is_single_selection: bool,
    #[prost(string, repeated, tag = "94002")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Errors {
    #[prost(message, repeated, tag = "31001")]
    pub factors: ::prost::alloc::vec::Vec<Factor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "32001")]
    pub date: ::core::option::Option<Date>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportModel {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportStep {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "118001")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "118002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "118007")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "118003")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "118004")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "118005")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "118006")]
    pub state: ::core::option::Option<StepState>,
    #[prost(message, optional, tag = "122001")]
    pub model: ::core::option::Option<ExportModel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportTableTask {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "2199007")]
    pub duration: f64,
    #[prost(string, tag = "2199009")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2199010")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2199011")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2199012")]
    pub size: i32,
    #[prost(string, tag = "204001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "205001")]
    pub export_name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "205002")]
    pub schema_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "205003")]
    pub export_type: ::prost::alloc::string::String,
    #[prost(string, tag = "205004")]
    pub export_to_id: ::prost::alloc::string::String,
    #[prost(string, tag = "205005")]
    pub export_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "205006")]
    pub namespaces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "205007")]
    pub exported_schema_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2199001")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "2199002")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "2199003")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199004")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199005")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199006")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199008")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "2199013")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportWorkflowTask {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "2199007")]
    pub duration: f64,
    #[prost(string, tag = "2199009")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2199010")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2199011")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2199012")]
    pub size: i32,
    #[prost(string, tag = "204001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "207001")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, tag = "207002")]
    pub file_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2199001")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "2199002")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "2199003")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199004")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199005")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199006")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199008")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "2199013")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct F64Values {
    #[prost(double, repeated, tag = "164001")]
    pub values: ::prost::alloc::vec::Vec<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Factor {
    #[prost(string, tag = "41001")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "41002")]
    pub r#type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FactorsProperty {
    #[prost(string, tag = "90001")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "90002")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "91001")]
    pub default_value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailedState {
    #[prost(string, tag = "2194001")]
    pub error: ::prost::alloc::string::String,
    #[prost(string, tag = "2194002")]
    pub reason: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileDocument {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(string, tag = "27001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "27002")]
    pub folder_id: ::prost::alloc::string::String,
    #[prost(string, tag = "42001")]
    pub data_uri: ::prost::alloc::string::String,
    #[prost(int32, tag = "42003")]
    pub size: i32,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "42002")]
    pub metadata: ::core::option::Option<EFileMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileMetadata {
    #[prost(string, tag = "43001")]
    pub content_type: ::prost::alloc::string::String,
    #[prost(string, tag = "43002")]
    pub cache_control: ::prost::alloc::string::String,
    #[prost(string, tag = "43003")]
    pub content_encoding: ::prost::alloc::string::String,
    #[prost(string, tag = "43004")]
    pub content_language: ::prost::alloc::string::String,
    #[prost(string, tag = "43005")]
    pub md5_hash: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileSummary {
    #[prost(int32, tag = "182001")]
    pub n: i32,
    #[prost(int32, tag = "182002")]
    pub size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Filter {
    #[prost(string, tag = "46001")]
    pub logical: ::prost::alloc::string::String,
    #[prost(bool, tag = "46002")]
    pub not: bool,
    #[prost(message, repeated, tag = "46003")]
    pub filter_exprs: ::prost::alloc::vec::Vec<EFilterTopExpr>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterExpr {
    #[prost(string, tag = "48001")]
    pub filter_op: ::prost::alloc::string::String,
    #[prost(string, tag = "48002")]
    pub string_value: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "48003")]
    pub factor: ::core::option::Option<Factor>,
    #[prost(message, repeated, tag = "48004")]
    pub pre_processors: ::prost::alloc::vec::Vec<PreProcessor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterExpr2d {
    #[prost(string, tag = "48001")]
    pub filter_op: ::prost::alloc::string::String,
    #[prost(string, tag = "48002")]
    pub string_value: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "48003")]
    pub factor: ::core::option::Option<Factor>,
    #[prost(message, repeated, tag = "48004")]
    pub pre_processors: ::prost::alloc::vec::Vec<PreProcessor>,
    #[prost(message, optional, tag = "49001")]
    pub factor2: ::core::option::Option<Factor>,
    #[prost(message, repeated, tag = "49002")]
    pub pre_processors2: ::prost::alloc::vec::Vec<PreProcessor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterTopExpr {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Filters {
    #[prost(bool, tag = "50001")]
    pub remove_na_n: bool,
    #[prost(message, repeated, tag = "50002")]
    pub named_filters: ::prost::alloc::vec::Vec<NamedFilter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FolderDocument {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(string, tag = "27001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "27002")]
    pub folder_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FormulaProperty {
    #[prost(string, tag = "90001")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "90002")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "91001")]
    pub default_value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GarbageObject {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GarbageTasks {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "2197001")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2197002")]
    pub deleted_task_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2197003")]
    pub added_task_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2197004")]
    pub deleted_step_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GarbageTasks2 {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "2198001")]
    pub date: ::prost::alloc::string::String,
    #[prost(string, tag = "2198002")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2198003")]
    pub deleted_task_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2198004")]
    pub added_task_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2198005")]
    pub deleted_step_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GateNode {
    #[prost(string, tag = "148001")]
    pub node_id: ::prost::alloc::string::String,
    #[prost(string, tag = "148002")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "148003")]
    pub crosstab: ::core::option::Option<Crosstab>,
    #[prost(message, repeated, tag = "148004")]
    pub children: ::prost::alloc::vec::Vec<GateNode>,
    #[prost(message, repeated, tag = "148005")]
    pub statistics: ::prost::alloc::vec::Vec<StatisticNode>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GateOperatorModel {
    #[prost(message, repeated, tag = "150001")]
    pub roots: ::prost::alloc::vec::Vec<GateNode>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GatherRelation {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "109002")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "109003")]
    pub value_name: ::prost::alloc::string::String,
    #[prost(string, tag = "109004")]
    pub variable_name: ::prost::alloc::string::String,
    #[prost(string, tag = "109005")]
    pub value_type: ::prost::alloc::string::String,
    #[prost(string, tag = "109006")]
    pub gather_type: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "109001")]
    pub relation: ::core::option::Option<::prost::alloc::boxed::Box<ERelation>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenericEvent {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "35001")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "35002")]
    pub content: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "32001")]
    pub date: ::core::option::Option<Date>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitOperator {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(string, tag = "59001")]
    pub path: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "57001")]
    pub properties: ::prost::alloc::vec::Vec<EProperty>,
    #[prost(message, optional, tag = "57002")]
    pub operator_spec: ::core::option::Option<OperatorSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitProjectTask {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "2199007")]
    pub duration: f64,
    #[prost(string, tag = "2199009")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2199010")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2199011")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2199012")]
    pub size: i32,
    #[prost(message, repeated, tag = "2199001")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "2199002")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "2199003")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199004")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199005")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199006")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199008")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "2199013")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlTask {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "2199007")]
    pub duration: f64,
    #[prost(string, tag = "2199009")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2199010")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2199011")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2199012")]
    pub size: i32,
    #[prost(int32, tag = "218003")]
    pub split: i32,
    #[prost(double, tag = "218004")]
    pub x_cell_resolution: f64,
    #[prost(double, tag = "218005")]
    pub y_cell_resolution: f64,
    #[prost(int32, tag = "218007")]
    pub layer: i32,
    #[prost(message, repeated, tag = "2199001")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "2199002")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "2199003")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199004")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199005")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199006")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199008")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "2199013")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "218001")]
    pub cube_query_task: ::core::option::Option<CubeQueryTask>,
    #[prost(message, repeated, tag = "218002")]
    pub palettes: ::prost::alloc::vec::Vec<EPalette>,
    #[prost(message, optional, tag = "218006")]
    pub range: ::core::option::Option<Rectangle>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphicalFactor {
    #[prost(message, optional, tag = "51001")]
    pub factor: ::core::option::Option<Factor>,
    #[prost(message, optional, tag = "51002")]
    pub rectangle: ::core::option::Option<Rectangle>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByRelation {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "111002")]
    pub group: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, boxed, tag = "111001")]
    pub relation: ::core::option::Option<::prost::alloc::boxed::Box<ERelation>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupStep {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "118001")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "118002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "118007")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "146001")]
    pub app_id: ::prost::alloc::string::String,
    #[prost(string, tag = "146002")]
    pub app_name: ::prost::alloc::string::String,
    #[prost(string, tag = "146003")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "118003")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "118004")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "118005")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "118006")]
    pub state: ::core::option::Option<StepState>,
    #[prost(message, optional, tag = "146004")]
    pub offset: ::core::option::Option<Point>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct I32Values {
    #[prost(int32, repeated, tag = "163001")]
    pub values: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdObject {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportGitDatasetTask {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "2199007")]
    pub duration: f64,
    #[prost(string, tag = "2199009")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2199010")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2199011")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2199012")]
    pub size: i32,
    #[prost(string, tag = "204001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "210002")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "210003")]
    pub git_token: ::prost::alloc::string::String,
    #[prost(string, tag = "210004")]
    pub schema_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2199001")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "2199002")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "2199003")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199004")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199005")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199006")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199008")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "2199013")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "210001")]
    pub url: ::core::option::Option<Url>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportGitWorkflowTask {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "2199007")]
    pub duration: f64,
    #[prost(string, tag = "2199009")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2199010")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2199011")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2199012")]
    pub size: i32,
    #[prost(string, tag = "204001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "208001")]
    pub file_id: ::prost::alloc::string::String,
    #[prost(string, tag = "208002")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, tag = "208003")]
    pub git_token: ::prost::alloc::string::String,
    #[prost(string, tag = "209002")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2199001")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "2199002")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "2199003")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199004")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199005")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199006")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199008")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "2199013")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "209001")]
    pub url: ::core::option::Option<Url>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportWorkflowTask {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "2199007")]
    pub duration: f64,
    #[prost(string, tag = "2199009")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2199010")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2199011")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2199012")]
    pub size: i32,
    #[prost(string, tag = "204001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "208001")]
    pub file_id: ::prost::alloc::string::String,
    #[prost(string, tag = "208002")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, tag = "208003")]
    pub git_token: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2199001")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "2199002")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "2199003")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199004")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199005")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199006")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199008")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "2199013")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InMemoryRelation {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "113001")]
    pub in_memory_table: ::core::option::Option<Table>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InStep {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "118001")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "118002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "118007")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "118003")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "118004")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "118005")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "118006")]
    pub state: ::core::option::Option<StepState>,
    #[prost(message, optional, tag = "125001")]
    pub group_port_position: ::core::option::Option<Point>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitState {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputPort {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "76001")]
    pub link_type: ::prost::alloc::string::String,
    #[prost(string, tag = "76002")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JetPalette {
    #[prost(int32, tag = "69001")]
    pub backcolor: i32,
    #[prost(bool, tag = "70001")]
    pub is_user_defined: bool,
    #[prost(message, repeated, tag = "69002")]
    pub properties: ::prost::alloc::vec::Vec<PropertyValue>,
    #[prost(message, repeated, tag = "70002")]
    pub double_color_elements: ::prost::alloc::vec::Vec<DoubleColorElement>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinOperator {
    #[prost(string, tag = "116001")]
    pub join_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "116002")]
    pub left_pair: ::core::option::Option<ColumnPair>,
    #[prost(message, optional, tag = "116003")]
    pub right_relation: ::core::option::Option<ERelation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinStep {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "118001")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "118002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "118007")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "118003")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "118004")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "118005")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "118006")]
    pub state: ::core::option::Option<StepState>,
    #[prost(message, optional, tag = "144001")]
    pub model: ::core::option::Option<JoinStepModel>,
    #[prost(message, repeated, tag = "144002")]
    pub right_attributes: ::prost::alloc::vec::Vec<Attribute>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinStepModel {
    #[prost(string, tag = "145003")]
    pub right_prefix: ::prost::alloc::string::String,
    #[prost(string, tag = "145004")]
    pub join_type: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "145001")]
    pub left_factors: ::prost::alloc::vec::Vec<Factor>,
    #[prost(message, repeated, tag = "145002")]
    pub right_factors: ::prost::alloc::vec::Vec<Factor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Labels {
    #[prost(message, repeated, tag = "55001")]
    pub factors: ::prost::alloc::vec::Vec<Factor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LibraryTask {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "2199007")]
    pub duration: f64,
    #[prost(string, tag = "2199009")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2199010")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2199011")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2199012")]
    pub size: i32,
    #[prost(message, repeated, tag = "2199001")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "2199002")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "2199003")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199004")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199005")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199006")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199008")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "2199013")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Link {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "56001")]
    pub input_id: ::prost::alloc::string::String,
    #[prost(string, tag = "56002")]
    pub output_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Lock {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "1887001")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MappingFactor {
    #[prost(string, tag = "41001")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "41002")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "139001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "139002")]
    pub ontology_mapping: ::prost::alloc::string::String,
    #[prost(string, tag = "139003")]
    pub crosstab_mapping: ::prost::alloc::string::String,
    #[prost(string, tag = "139004")]
    pub cardinality: ::prost::alloc::string::String,
    #[prost(string, tag = "138001")]
    pub factor_name: ::prost::alloc::string::String,
    #[prost(bool, tag = "138002")]
    pub is_single: bool,
    #[prost(bool, tag = "138003")]
    pub is_required: bool,
    #[prost(message, repeated, tag = "139005")]
    pub factors: ::prost::alloc::vec::Vec<Factor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MappingFilter {
    #[prost(string, tag = "140001")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "140002")]
    pub description: ::prost::alloc::string::String,
    #[prost(bool, tag = "140004")]
    pub is_required: bool,
    #[prost(message, optional, tag = "140003")]
    pub named_filter: ::core::option::Option<NamedFilter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MeltStep {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "118001")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "118002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "118007")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "118003")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "118004")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "118005")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "118006")]
    pub state: ::core::option::Option<StepState>,
    #[prost(message, optional, tag = "141001")]
    pub model: ::core::option::Option<MeltStepModel>,
    #[prost(message, repeated, tag = "141002")]
    pub melted_attributes: ::prost::alloc::vec::Vec<Attribute>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MeltStepModel {
    #[prost(string, tag = "142002")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "142003")]
    pub selection_pattern: ::prost::alloc::string::String,
    #[prost(string, tag = "142004")]
    pub factor_type: ::prost::alloc::string::String,
    #[prost(string, tag = "142005")]
    pub gather_type: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "142001")]
    pub factors: ::prost::alloc::vec::Vec<Factor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaFactor {
    #[prost(string, tag = "41001")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "41002")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "139001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "139002")]
    pub ontology_mapping: ::prost::alloc::string::String,
    #[prost(string, tag = "139003")]
    pub crosstab_mapping: ::prost::alloc::string::String,
    #[prost(string, tag = "139004")]
    pub cardinality: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "139005")]
    pub factors: ::prost::alloc::vec::Vec<Factor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelStep {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "118001")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "118002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "118007")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "118003")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "118004")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "118005")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "118006")]
    pub state: ::core::option::Option<StepState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamedFilter {
    #[prost(string, tag = "46001")]
    pub logical: ::prost::alloc::string::String,
    #[prost(bool, tag = "46002")]
    pub not: bool,
    #[prost(string, tag = "47002")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "46003")]
    pub filter_exprs: ::prost::alloc::vec::Vec<EFilterTopExpr>,
    #[prost(message, repeated, tag = "47001")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamespaceStep {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "118001")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "118002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "118007")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "118003")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "118004")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "118005")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "118006")]
    pub state: ::core::option::Option<StepState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Operator {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "57001")]
    pub properties: ::prost::alloc::vec::Vec<EProperty>,
    #[prost(message, optional, tag = "57002")]
    pub operator_spec: ::core::option::Option<OperatorSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperatorInputSpec {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperatorModel {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperatorOutputSpec {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperatorRef {
    #[prost(string, tag = "58001")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "58002")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "58003")]
    pub operator_id: ::prost::alloc::string::String,
    #[prost(string, tag = "58004")]
    pub operator_kind: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "58005")]
    pub property_values: ::prost::alloc::vec::Vec<PropertyValue>,
    #[prost(message, optional, tag = "58006")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "58007")]
    pub operator_spec: ::core::option::Option<OperatorSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperatorResult {
    #[prost(message, repeated, tag = "65001")]
    pub tables: ::prost::alloc::vec::Vec<Table>,
    #[prost(message, repeated, tag = "65002")]
    pub join_operators: ::prost::alloc::vec::Vec<JoinOperator>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperatorSettings {
    #[prost(string, tag = "151001")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "151002")]
    pub operator_ref: ::core::option::Option<OperatorRef>,
    #[prost(message, repeated, tag = "151003")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "151004")]
    pub operator_model: ::core::option::Option<EOperatorModel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperatorSpec {
    #[prost(string, tag = "133001")]
    pub ontology_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "133002")]
    pub ontology_version: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "133003")]
    pub input_specs: ::prost::alloc::vec::Vec<EOperatorInputSpec>,
    #[prost(message, repeated, tag = "133004")]
    pub output_specs: ::prost::alloc::vec::Vec<OperatorOutputSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperatorUnitTest {
    #[prost(string, tag = "66001")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "66002")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "66004")]
    pub input_file_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "66005")]
    pub input_data_uri: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "66006")]
    pub output_data_uri: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "66007")]
    pub columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "66008")]
    pub rows: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "66009")]
    pub colors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "66010")]
    pub labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "66011")]
    pub y_axis: ::prost::alloc::string::String,
    #[prost(string, tag = "66012")]
    pub x_axis: ::prost::alloc::string::String,
    #[prost(double, tag = "66013")]
    pub abs_tol: f64,
    #[prost(double, tag = "66014")]
    pub rel_tol: f64,
    #[prost(string, tag = "66015")]
    pub equality_method: ::prost::alloc::string::String,
    #[prost(double, tag = "66016")]
    pub r2: f64,
    #[prost(string, repeated, tag = "66017")]
    pub skip_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "66003")]
    pub property_values: ::prost::alloc::vec::Vec<PropertyValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutStep {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "118001")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "118002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "118007")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "118003")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "118004")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "118005")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "118006")]
    pub state: ::core::option::Option<StepState>,
    #[prost(message, optional, tag = "126001")]
    pub group_port_position: ::core::option::Option<Point>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputPort {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "76001")]
    pub link_type: ::prost::alloc::string::String,
    #[prost(string, tag = "76002")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pair {
    #[prost(string, tag = "68001")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "68002")]
    pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PairwiseRelation {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "114002")]
    pub row_attributes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "114003")]
    pub col_attributes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "114004")]
    pub label_attributes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "114005")]
    pub color_attributes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "114006")]
    pub x_attribute: ::prost::alloc::string::String,
    #[prost(string, tag = "114007")]
    pub y_attribute: ::prost::alloc::string::String,
    #[prost(string, tag = "114008")]
    pub error_attribute: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "114001")]
    pub relation: ::core::option::Option<::prost::alloc::boxed::Box<ERelation>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Palette {
    #[prost(int32, tag = "69001")]
    pub backcolor: i32,
    #[prost(message, repeated, tag = "69002")]
    pub properties: ::prost::alloc::vec::Vec<PropertyValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRecord {
    #[prost(string, tag = "34001")]
    pub p: ::prost::alloc::string::String,
    #[prost(string, tag = "34002")]
    pub t: ::prost::alloc::string::String,
    #[prost(string, tag = "34003")]
    pub d: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRecords {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "33001")]
    pub u: ::prost::alloc::string::String,
    #[prost(string, tag = "33002")]
    pub c_i: ::prost::alloc::string::String,
    #[prost(string, tag = "33003")]
    pub o_i: ::prost::alloc::string::String,
    #[prost(string, tag = "33004")]
    pub o_r: ::prost::alloc::string::String,
    #[prost(string, tag = "33005")]
    pub o_k: ::prost::alloc::string::String,
    #[prost(int32, tag = "33006")]
    pub s: i32,
    #[prost(message, optional, tag = "32001")]
    pub date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "33007")]
    pub rs: ::prost::alloc::vec::Vec<PatchRecord>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PendingState {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PersistentObject {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Plan {
    #[prost(string, tag = "227001")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "227002")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "227003")]
    pub payment_provider_plan_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "227004")]
    pub descriptions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(double, tag = "227005")]
    pub price: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Point {
    #[prost(double, tag = "75001")]
    pub x: f64,
    #[prost(double, tag = "75002")]
    pub y: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Port {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "76001")]
    pub link_type: ::prost::alloc::string::String,
    #[prost(string, tag = "76002")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreProcessor {
    #[prost(string, tag = "237001")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "237002")]
    pub operator_ref: ::core::option::Option<OperatorRef>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Principal {
    #[prost(string, tag = "78001")]
    pub principal_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Privilege {
    #[prost(string, tag = "79001")]
    pub r#type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Profile {
    #[prost(string, tag = "80001")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Profiles {
    #[prost(message, optional, tag = "86001")]
    pub api_profile: ::core::option::Option<ApiCallProfile>,
    #[prost(message, optional, tag = "86002")]
    pub table_profile: ::core::option::Option<TableProfile>,
    #[prost(message, optional, tag = "86003")]
    pub cpu_time_profile: ::core::option::Option<CpuTimeProfile>,
    #[prost(message, optional, tag = "86004")]
    pub storage_profile: ::core::option::Option<StorageProfile>,
    #[prost(message, optional, tag = "86005")]
    pub run_profile: ::core::option::Option<RunProfile>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Project {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectDocument {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(string, tag = "27001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "27002")]
    pub folder_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectTask {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "2199007")]
    pub duration: f64,
    #[prost(string, tag = "2199009")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2199010")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2199011")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2199012")]
    pub size: i32,
    #[prost(string, tag = "204001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2199001")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "2199002")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "2199003")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199004")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199005")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199006")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199008")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "2199013")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Properties {
    #[prost(message, repeated, tag = "98001")]
    pub properties: ::prost::alloc::vec::Vec<EProperty>,
    #[prost(message, repeated, tag = "98002")]
    pub property_values: ::prost::alloc::vec::Vec<PropertyValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Property {
    #[prost(string, tag = "90001")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "90002")]
    pub description: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PropertyValue {
    #[prost(string, tag = "97001")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "97002")]
    pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RDescription {
    #[prost(string, tag = "16001")]
    pub package: ::prost::alloc::string::String,
    #[prost(string, tag = "16002")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "16003")]
    pub depends: ::prost::alloc::string::String,
    #[prost(string, tag = "16004")]
    pub imports: ::prost::alloc::string::String,
    #[prost(string, tag = "16005")]
    pub linking_to: ::prost::alloc::string::String,
    #[prost(string, tag = "16006")]
    pub suggests: ::prost::alloc::string::String,
    #[prost(string, tag = "16007")]
    pub license: ::prost::alloc::string::String,
    #[prost(string, tag = "16008")]
    pub md5sum: ::prost::alloc::string::String,
    #[prost(string, tag = "16009")]
    pub needs_compilation: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RLibrary {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "17001")]
    pub r_description: ::core::option::Option<RDescription>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ROperator {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(string, tag = "59001")]
    pub path: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "57001")]
    pub properties: ::prost::alloc::vec::Vec<EProperty>,
    #[prost(message, optional, tag = "57002")]
    pub operator_spec: ::core::option::Option<OperatorSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RProxy {
    #[prost(string, tag = "20001")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "20002")]
    pub target_url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RSourceLibrary {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(string, tag = "18001")]
    pub file_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "17001")]
    pub r_description: ::core::option::Option<RDescription>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RampPalette {
    #[prost(int32, tag = "69001")]
    pub backcolor: i32,
    #[prost(bool, tag = "70001")]
    pub is_user_defined: bool,
    #[prost(message, repeated, tag = "69002")]
    pub properties: ::prost::alloc::vec::Vec<PropertyValue>,
    #[prost(message, repeated, tag = "70002")]
    pub double_color_elements: ::prost::alloc::vec::Vec<DoubleColorElement>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RangeRelation {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(int32, tag = "104002")]
    pub start: i32,
    #[prost(int32, tag = "104003")]
    pub len: i32,
    #[prost(message, optional, boxed, tag = "104001")]
    pub relation: ::core::option::Option<::prost::alloc::boxed::Box<ERelation>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rectangle {
    #[prost(message, optional, tag = "99001")]
    pub extent: ::core::option::Option<Point>,
    #[prost(message, optional, tag = "99002")]
    pub top_left: ::core::option::Option<Point>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReferenceRelation {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "105001")]
    pub relation: ::core::option::Option<::prost::alloc::boxed::Box<ERelation>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Relation {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelationStep {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "118001")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "118002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "118007")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "118003")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "118004")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "118005")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "118006")]
    pub state: ::core::option::Option<StepState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenameRelation {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "107002")]
    pub in_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "107003")]
    pub out_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, boxed, tag = "107001")]
    pub relation: ::core::option::Option<::prost::alloc::boxed::Box<ERelation>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenvInstalledLibrary {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(string, tag = "240001")]
    pub path: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "17001")]
    pub r_description: ::core::option::Option<RDescription>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceSummary {
    #[prost(double, tag = "184001")]
    pub storage: f64,
    #[prost(double, tag = "184002")]
    pub used_storage: f64,
    #[prost(double, tag = "184003")]
    pub cpu_time: f64,
    #[prost(double, tag = "184004")]
    pub used_cpu_time: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunComputationTask {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "2199007")]
    pub duration: f64,
    #[prost(string, tag = "2199009")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2199010")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2199011")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2199012")]
    pub size: i32,
    #[prost(string, tag = "204001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "214002")]
    pub remove_on_gc: bool,
    #[prost(string, repeated, tag = "214003")]
    pub schema_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "215001")]
    pub parent_task_id: ::prost::alloc::string::String,
    #[prost(string, tag = "215002")]
    pub file_result_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2199001")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "2199002")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "2199003")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199004")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199005")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199006")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199008")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "2199013")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "214001")]
    pub query: ::core::option::Option<CubeQuery>,
    #[prost(message, optional, tag = "215003")]
    pub computed_relation: ::core::option::Option<ERelation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunProfile {
    #[prost(string, tag = "80001")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "81001")]
    pub memory: i32,
    #[prost(int32, tag = "81002")]
    pub kernel_memory: i32,
    #[prost(int32, tag = "81003")]
    pub blkio_weight: i32,
    #[prost(int32, tag = "81004")]
    pub pids_limit: i32,
    #[prost(int32, tag = "81005")]
    pub ulimits_nofile: i32,
    #[prost(int32, tag = "81006")]
    pub timeout: i32,
    #[prost(string, tag = "81007")]
    pub storage_size: ::prost::alloc::string::String,
    #[prost(string, tag = "81008")]
    pub cpuset_cpus: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunWebAppTask {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "2199007")]
    pub duration: f64,
    #[prost(string, tag = "2199009")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2199010")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2199011")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2199012")]
    pub size: i32,
    #[prost(string, tag = "204001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "211001")]
    pub operator_id: ::prost::alloc::string::String,
    #[prost(string, tag = "211002")]
    pub cube_query_task_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2199001")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "2199002")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "2199003")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199004")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199005")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199006")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199008")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "2199013")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "211003")]
    pub url: ::core::option::Option<Url>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunWorkflowTask {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "2199007")]
    pub duration: f64,
    #[prost(string, tag = "2199009")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2199010")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2199011")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2199012")]
    pub size: i32,
    #[prost(string, tag = "204001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "206001")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, tag = "206002")]
    pub workflow_rev: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2199001")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "2199002")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "2199003")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199004")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199005")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199006")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199008")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "2199013")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunningDependentState {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunningState {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveComputationResultTask {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "2199007")]
    pub duration: f64,
    #[prost(string, tag = "2199009")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2199010")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2199011")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2199012")]
    pub size: i32,
    #[prost(string, tag = "204001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "214002")]
    pub remove_on_gc: bool,
    #[prost(string, repeated, tag = "214003")]
    pub schema_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "215001")]
    pub parent_task_id: ::prost::alloc::string::String,
    #[prost(string, tag = "215002")]
    pub file_result_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2199001")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "2199002")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "2199003")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199004")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199005")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199006")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199008")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "2199013")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "214001")]
    pub query: ::core::option::Option<CubeQuery>,
    #[prost(message, optional, tag = "215003")]
    pub computed_relation: ::core::option::Option<ERelation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(string, tag = "27001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "27002")]
    pub folder_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "167001")]
    pub n_rows: i32,
    #[prost(string, tag = "167003")]
    pub data_directory: ::prost::alloc::string::String,
    #[prost(int32, tag = "167005")]
    pub size: i32,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "167002")]
    pub columns: ::prost::alloc::vec::Vec<EColumnSchema>,
    #[prost(message, optional, tag = "167004")]
    pub relation: ::core::option::Option<ERelation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResult {
    #[prost(int32, tag = "73001")]
    pub total_rows: i32,
    #[prost(string, tag = "73002")]
    pub bookmark: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "73003")]
    pub rows: ::prost::alloc::vec::Vec<EPersistentObject>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SelectPairwiseRelation {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "115004")]
    pub pairwise_col_group: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "115005")]
    pub pairwise_row_group: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "115006")]
    pub pair_attributes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "115007")]
    pub n_axis: i32,
    #[prost(message, optional, boxed, tag = "115001")]
    pub column_relation: ::core::option::Option<::prost::alloc::boxed::Box<ERelation>>,
    #[prost(message, optional, boxed, tag = "115002")]
    pub row_relation: ::core::option::Option<::prost::alloc::boxed::Box<ERelation>>,
    #[prost(message, optional, boxed, tag = "115003")]
    pub qt_relation: ::core::option::Option<::prost::alloc::boxed::Box<ERelation>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShinyOperator {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(string, tag = "59001")]
    pub path: ::prost::alloc::string::String,
    #[prost(bool, tag = "62001")]
    pub is_view_only: bool,
    #[prost(string, tag = "62002")]
    pub entry_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "57001")]
    pub properties: ::prost::alloc::vec::Vec<EProperty>,
    #[prost(message, optional, tag = "57002")]
    pub operator_spec: ::core::option::Option<OperatorSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimpleRelation {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(int32, tag = "102001")]
    pub index: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartProcess {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "220001")]
    pub executable: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "220002")]
    pub arguments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "220004")]
    pub timeout: i32,
    #[prost(int32, tag = "220005")]
    pub pid: i32,
    #[prost(string, tag = "220006")]
    pub script: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "220003")]
    pub ulimits: ::core::option::Option<Ulimits>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct State {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatisticNode {
    #[prost(string, tag = "149001")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "149002")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Step {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "118001")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "118002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "118007")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "118003")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "118004")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "118005")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "118006")]
    pub state: ::core::option::Option<StepState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StepModel {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StepState {
    #[prost(string, tag = "121001")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "121002")]
    pub task_state: ::core::option::Option<EState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageProfile {
    #[prost(string, tag = "80001")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "82001")]
    pub size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StrValues {
    #[prost(string, repeated, tag = "162001")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringColorElement {
    #[prost(int32, tag = "13001")]
    pub color: i32,
    #[prost(string, tag = "157001")]
    pub string_value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringProperty {
    #[prost(string, tag = "90001")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "90002")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "91001")]
    pub default_value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscriptionPlan {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(string, tag = "228001")]
    pub provider_key: ::prost::alloc::string::String,
    #[prost(string, tag = "228002")]
    pub payment_provider_plan_id: ::prost::alloc::string::String,
    #[prost(string, tag = "228003")]
    pub checkout_session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "228004")]
    pub subscription_id: ::prost::alloc::string::String,
    #[prost(string, tag = "228005")]
    pub status: ::prost::alloc::string::String,
    #[prost(string, tag = "228006")]
    pub payment_method_status: ::prost::alloc::string::String,
    #[prost(string, tag = "228007")]
    pub ip: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Summary {
    #[prost(message, optional, tag = "183001")]
    pub table_summary: ::core::option::Option<TableSummary>,
    #[prost(message, optional, tag = "183002")]
    pub computed_table_summary: ::core::option::Option<TableSummary>,
    #[prost(message, optional, tag = "183003")]
    pub query_table_summary: ::core::option::Option<TableSummary>,
    #[prost(message, optional, tag = "183004")]
    pub task_summary: ::core::option::Option<TaskSummary>,
    #[prost(message, optional, tag = "183005")]
    pub file_summary: ::core::option::Option<FileSummary>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Table {
    #[prost(int32, tag = "158001")]
    pub n_rows: i32,
    #[prost(message, optional, tag = "158002")]
    pub properties: ::core::option::Option<TableProperties>,
    #[prost(message, repeated, tag = "158003")]
    pub columns: ::prost::alloc::vec::Vec<Column>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableProfile {
    #[prost(string, tag = "80001")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "84001")]
    pub n_rows: i32,
    #[prost(int32, tag = "84002")]
    pub n_cols: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableProperties {
    #[prost(string, tag = "159001")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "159002")]
    pub sort_order: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "159003")]
    pub ascending: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableRelation {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(int32, tag = "102001")]
    pub index: i32,
    #[prost(int32, tag = "103002")]
    pub n_rows: i32,
    #[prost(string, tag = "103003")]
    pub data_dir: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "103001")]
    pub meta_data: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, repeated, tag = "103004")]
    pub attributes: ::prost::alloc::vec::Vec<Attribute>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableSchema {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(string, tag = "27001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "27002")]
    pub folder_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "167001")]
    pub n_rows: i32,
    #[prost(string, tag = "167003")]
    pub data_directory: ::prost::alloc::string::String,
    #[prost(int32, tag = "167005")]
    pub size: i32,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "167002")]
    pub columns: ::prost::alloc::vec::Vec<EColumnSchema>,
    #[prost(message, optional, tag = "167004")]
    pub relation: ::core::option::Option<ERelation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableStep {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "118001")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "118002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "118007")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "118003")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "118004")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "118005")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "118006")]
    pub state: ::core::option::Option<StepState>,
    #[prost(message, optional, tag = "127001")]
    pub model: ::core::option::Option<TableStepModel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableStepModel {
    #[prost(string, tag = "128002")]
    pub filter_selector: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "128001")]
    pub relation: ::core::option::Option<ERelation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableSummary {
    #[prost(int32, tag = "180001")]
    pub n: i32,
    #[prost(int32, tag = "180002")]
    pub size: i32,
    #[prost(int32, tag = "180003")]
    pub nr: i32,
    #[prost(int32, tag = "180004")]
    pub nc: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Task {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "2199007")]
    pub duration: f64,
    #[prost(string, tag = "2199009")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2199010")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2199011")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2199012")]
    pub size: i32,
    #[prost(message, repeated, tag = "2199001")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "2199002")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "2199003")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199004")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199005")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199006")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199008")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "2199013")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskDataEvent {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "36001")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "38001")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "32001")]
    pub date: ::core::option::Option<Date>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskEvent {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "36001")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "32001")]
    pub date: ::core::option::Option<Date>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskLogEvent {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "36001")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(string, tag = "39001")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "32001")]
    pub date: ::core::option::Option<Date>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskProgressEvent {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "36001")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(string, tag = "40001")]
    pub message: ::prost::alloc::string::String,
    #[prost(int32, tag = "40002")]
    pub total: i32,
    #[prost(int32, tag = "40003")]
    pub actual: i32,
    #[prost(message, optional, tag = "32001")]
    pub date: ::core::option::Option<Date>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskStateEvent {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "36001")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "32001")]
    pub date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "37001")]
    pub state: ::core::option::Option<EState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskSummary {
    #[prost(int32, tag = "181001")]
    pub n: i32,
    #[prost(double, tag = "181002")]
    pub duration: f64,
    #[prost(int32, tag = "181003")]
    pub size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaxId {
    #[prost(string, tag = "232001")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "232002")]
    pub value: ::prost::alloc::string::String,
    #[prost(bool, tag = "232003")]
    pub is_valid: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Team {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(string, tag = "222001")]
    pub email: ::prost::alloc::string::String,
    #[prost(bool, tag = "222002")]
    pub is_validated: bool,
    #[prost(string, tag = "222003")]
    pub domain: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "222004")]
    pub roles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "222006")]
    pub invited_by_username: ::prost::alloc::string::String,
    #[prost(int32, tag = "222007")]
    pub invitation_counts: i32,
    #[prost(int32, tag = "222008")]
    pub max_invitation: i32,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "222005")]
    pub team_acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "222009")]
    pub billing_info: ::core::option::Option<BillingInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestOperatorTask {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "2199007")]
    pub duration: f64,
    #[prost(string, tag = "2199009")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2199010")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2199011")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2199012")]
    pub size: i32,
    #[prost(string, tag = "204001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "203001")]
    pub operator_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "203002")]
    pub test_required: bool,
    #[prost(message, repeated, tag = "2199001")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "2199002")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "2199003")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199004")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199005")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199006")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2199008")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "2199013")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Token {
    #[prost(string, tag = "226001")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(string, tag = "226003")]
    pub token: ::prost::alloc::string::String,
    #[prost(string, tag = "226004")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "226002")]
    pub expiry: ::core::option::Option<Date>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ulimits {
    #[prost(int32, tag = "219001")]
    pub core_file_size: i32,
    #[prost(int32, tag = "219002")]
    pub data_seg_size: i32,
    #[prost(int32, tag = "219003")]
    pub scheduling_priority: i32,
    #[prost(int32, tag = "219004")]
    pub file_size: i32,
    #[prost(int32, tag = "219005")]
    pub pending_signals: i32,
    #[prost(int32, tag = "219006")]
    pub max_locked_memory: i32,
    #[prost(int32, tag = "219007")]
    pub max_memory_size: i32,
    #[prost(int32, tag = "219008")]
    pub open_files: i32,
    #[prost(int32, tag = "219009")]
    pub pipe_size: i32,
    #[prost(int32, tag = "219010")]
    pub message_queues: i32,
    #[prost(int32, tag = "219011")]
    pub real_time_priority: i32,
    #[prost(int32, tag = "219012")]
    pub stack_size: i32,
    #[prost(int32, tag = "219013")]
    pub cpu_time: i32,
    #[prost(int32, tag = "219014")]
    pub max_user_processes: i32,
    #[prost(int32, tag = "219015")]
    pub virtual_memory: i32,
    #[prost(int32, tag = "219016")]
    pub file_locks: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnionRelation {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "106001")]
    pub relations: ::prost::alloc::vec::Vec<ERelation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Url {
    #[prost(string, tag = "221001")]
    pub uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(string, tag = "222001")]
    pub email: ::prost::alloc::string::String,
    #[prost(bool, tag = "222002")]
    pub is_validated: bool,
    #[prost(string, tag = "222003")]
    pub domain: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "222004")]
    pub roles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "222006")]
    pub invited_by_username: ::prost::alloc::string::String,
    #[prost(int32, tag = "222007")]
    pub invitation_counts: i32,
    #[prost(int32, tag = "222008")]
    pub max_invitation: i32,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "222005")]
    pub team_acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "222009")]
    pub billing_info: ::core::option::Option<BillingInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserSecret {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "224001")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(string, tag = "224002")]
    pub salt: ::prost::alloc::string::String,
    #[prost(string, tag = "224003")]
    pub hash_password: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "224004")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserSession {
    #[prost(message, optional, tag = "225001")]
    pub server_version: ::core::option::Option<Version>,
    #[prost(message, optional, tag = "225002")]
    pub user: ::core::option::Option<EUser>,
    #[prost(message, optional, tag = "225003")]
    pub token: ::core::option::Option<Token>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Version {
    #[prost(int32, tag = "234001")]
    pub major: i32,
    #[prost(int32, tag = "234002")]
    pub minor: i32,
    #[prost(int32, tag = "234003")]
    pub patch: i32,
    #[prost(string, tag = "234004")]
    pub tag: ::prost::alloc::string::String,
    #[prost(string, tag = "234005")]
    pub date: ::prost::alloc::string::String,
    #[prost(string, tag = "234006")]
    pub commit: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "234007")]
    pub features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViesInfo {
    #[prost(string, tag = "229001")]
    pub country_code: ::prost::alloc::string::String,
    #[prost(string, tag = "229002")]
    pub vat_number: ::prost::alloc::string::String,
    #[prost(string, tag = "229003")]
    pub request_date: ::prost::alloc::string::String,
    #[prost(bool, tag = "229004")]
    pub valid: bool,
    #[prost(string, tag = "229005")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "229006")]
    pub address: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewStep {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "118001")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "118002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "118007")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "118003")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "118004")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "118005")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "118006")]
    pub state: ::core::option::Option<StepState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebAppOperator {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(string, tag = "59001")]
    pub path: ::prost::alloc::string::String,
    #[prost(bool, tag = "62001")]
    pub is_view_only: bool,
    #[prost(string, tag = "62002")]
    pub entry_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "57001")]
    pub properties: ::prost::alloc::vec::Vec<EProperty>,
    #[prost(message, optional, tag = "57002")]
    pub operator_spec: ::core::option::Option<OperatorSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WhereRelation {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "110001")]
    pub relation: ::core::option::Option<::prost::alloc::boxed::Box<ERelation>>,
    #[prost(message, optional, tag = "110002")]
    pub filters: ::core::option::Option<Filters>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WizardStep {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "118001")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "118002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "118007")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "118003")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "118004")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "118005")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "118006")]
    pub state: ::core::option::Option<StepState>,
    #[prost(message, optional, tag = "130001")]
    pub model: ::core::option::Option<WizardStepModel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WizardStepModel {
    #[prost(string, tag = "131001")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "131002")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "131003")]
    pub app_design_type: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "131004")]
    pub factors: ::prost::alloc::vec::Vec<MappingFactor>,
    #[prost(message, repeated, tag = "131005")]
    pub filters: ::prost::alloc::vec::Vec<MappingFilter>,
    #[prost(message, repeated, tag = "131006")]
    pub steps: ::prost::alloc::vec::Vec<EStep>,
    #[prost(message, repeated, tag = "131007")]
    pub default_factors: ::prost::alloc::vec::Vec<MappingFactor>,
    #[prost(message, repeated, tag = "131008")]
    pub default_filters: ::prost::alloc::vec::Vec<MappingFilter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Worker {
    #[prost(string, tag = "186001")]
    pub status: ::prost::alloc::string::String,
    #[prost(string, tag = "186002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "186003")]
    pub uri: ::prost::alloc::string::String,
    #[prost(double, tag = "186004")]
    pub priority: f64,
    #[prost(int32, tag = "186005")]
    pub n_cpu: i32,
    #[prost(int32, tag = "186006")]
    pub n_thread: i32,
    #[prost(double, tag = "186007")]
    pub memory: f64,
    #[prost(int32, tag = "186008")]
    pub n_available_thread: i32,
    #[prost(double, tag = "186009")]
    pub available_memory: f64,
    #[prost(string, repeated, tag = "186010")]
    pub available_task_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "186011")]
    pub task_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "186012")]
    pub last_date_activity: ::prost::alloc::string::String,
    #[prost(int32, tag = "186013")]
    pub heart_beat: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerEndpoint {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(string, tag = "185001")]
    pub uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Workflow {
    #[prost(string, tag = "53001")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "74001")]
    pub is_deleted: bool,
    #[prost(string, tag = "74002")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "26001")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "26002")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "26007")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "26010")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "26011")]
    pub is_public: bool,
    #[prost(string, tag = "27001")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "27002")]
    pub folder_id: ::prost::alloc::string::String,
    #[prost(double, tag = "235004")]
    pub scale: f64,
    #[prost(message, optional, tag = "26003")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "26004")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "26005")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "26006")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "26008")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "26009")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "235001")]
    pub links: ::prost::alloc::vec::Vec<Link>,
    #[prost(message, repeated, tag = "235002")]
    pub steps: ::prost::alloc::vec::Vec<EStep>,
    #[prost(message, optional, tag = "235003")]
    pub offset: ::core::option::Option<Point>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct XyAxis {
    #[prost(string, tag = "236007")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "236001")]
    pub chart: ::core::option::Option<EChart>,
    #[prost(message, optional, tag = "236002")]
    pub colors: ::core::option::Option<Colors>,
    #[prost(message, optional, tag = "236003")]
    pub errors: ::core::option::Option<Errors>,
    #[prost(message, optional, tag = "236004")]
    pub labels: ::core::option::Option<Labels>,
    #[prost(message, optional, tag = "236005")]
    pub x_axis: ::core::option::Option<Axis>,
    #[prost(message, optional, tag = "236006")]
    pub y_axis: ::core::option::Option<Axis>,
    #[prost(message, repeated, tag = "236008")]
    pub preprocessors: ::prost::alloc::vec::Vec<PreProcessor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct XyAxisList {
    #[prost(message, repeated, tag = "238001")]
    pub rectangle_selections: ::prost::alloc::vec::Vec<Rectangle>,
    #[prost(message, repeated, tag = "238002")]
    pub xy_axis: ::prost::alloc::vec::Vec<XyAxis>,
}
/// Generated client implementations.
pub mod file_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct FileServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> FileServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> FileServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            FileServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::EFileDocument>,
        ) -> std::result::Result<tonic::Response<super::EFileDocument>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.FileService/create",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.FileService", "create"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRequest>,
        ) -> std::result::Result<tonic::Response<super::EFileDocument>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/tercen.FileService/get");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.FileService", "get"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::EFileDocument>,
        ) -> std::result::Result<tonic::Response<super::ResponseUpdate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.FileService/update",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.FileService", "update"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::ResponseDelete>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.FileService/delete",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.FileService", "delete"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn upload(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::ReqUpload>,
        ) -> std::result::Result<tonic::Response<super::RespUpload>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.FileService/upload",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.FileService", "upload"));
            self.inner.client_streaming(req, path, codec).await
        }
        pub async fn append(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::ReqAppend>,
        ) -> std::result::Result<tonic::Response<super::RespAppend>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.FileService/append",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.FileService", "append"));
            self.inner.client_streaming(req, path, codec).await
        }
        pub async fn download(
            &mut self,
            request: impl tonic::IntoRequest<super::ReqDownload>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::RespDownload>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.FileService/download",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.FileService", "download"));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod folder_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct FolderServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> FolderServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> FolderServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            FolderServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::EFolderDocument>,
        ) -> std::result::Result<
            tonic::Response<super::EFolderDocument>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.FolderService/create",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.FolderService", "create"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EFolderDocument>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/tercen.FolderService/get");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.FolderService", "get"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::EFolderDocument>,
        ) -> std::result::Result<tonic::Response<super::ResponseUpdate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.FolderService/update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.FolderService", "update"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::ResponseDelete>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.FolderService/delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.FolderService", "delete"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod table_schema_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct TableSchemaServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> TableSchemaServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TableSchemaServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            TableSchemaServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::ESchema>,
        ) -> std::result::Result<tonic::Response<super::ESchema>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TableSchemaService/create",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.TableSchemaService", "create"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRequest>,
        ) -> std::result::Result<tonic::Response<super::ESchema>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TableSchemaService/get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.TableSchemaService", "get"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::ESchema>,
        ) -> std::result::Result<tonic::Response<super::ResponseUpdate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TableSchemaService/update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.TableSchemaService", "update"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::ResponseDelete>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TableSchemaService/delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.TableSchemaService", "delete"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn upload_table(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::ReqUploadTable>,
        ) -> std::result::Result<
            tonic::Response<super::RespUploadTable>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TableSchemaService/uploadTable",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.TableSchemaService", "uploadTable"));
            self.inner.client_streaming(req, path, codec).await
        }
        pub async fn stream_table(
            &mut self,
            request: impl tonic::IntoRequest<super::ReqStreamTable>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::RespStreamTable>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TableSchemaService/streamTable",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.TableSchemaService", "streamTable"));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod task_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct TaskServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> TaskServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TaskServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            TaskServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::ETask>,
        ) -> std::result::Result<tonic::Response<super::ETask>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TaskService/create",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.TaskService", "create"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRequest>,
        ) -> std::result::Result<tonic::Response<super::ETask>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/tercen.TaskService/get");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.TaskService", "get"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::ETask>,
        ) -> std::result::Result<tonic::Response<super::ResponseUpdate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TaskService/update",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.TaskService", "update"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::ResponseDelete>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TaskService/delete",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.TaskService", "delete"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn run_task(
            &mut self,
            request: impl tonic::IntoRequest<super::ReqRunTask>,
        ) -> std::result::Result<tonic::Response<super::RespRunTask>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TaskService/runTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.TaskService", "runTask"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn cancel_task(
            &mut self,
            request: impl tonic::IntoRequest<super::ReqCancelTask>,
        ) -> std::result::Result<tonic::Response<super::RespCancelTask>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TaskService/cancelTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.TaskService", "cancelTask"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn wait_done(
            &mut self,
            request: impl tonic::IntoRequest<super::ReqWaitDone>,
        ) -> std::result::Result<tonic::Response<super::RespWaitDone>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TaskService/waitDone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.TaskService", "waitDone"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod workflow_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct WorkflowServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> WorkflowServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WorkflowServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            WorkflowServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::EWorkflow>,
        ) -> std::result::Result<tonic::Response<super::EWorkflow>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.WorkflowService/create",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.WorkflowService", "create"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRequest>,
        ) -> std::result::Result<tonic::Response<super::EWorkflow>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.WorkflowService/get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.WorkflowService", "get"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::EWorkflow>,
        ) -> std::result::Result<tonic::Response<super::ResponseUpdate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.WorkflowService/update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.WorkflowService", "update"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::ResponseDelete>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.WorkflowService/delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.WorkflowService", "delete"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_cube_query(
            &mut self,
            request: impl tonic::IntoRequest<super::ReqGetCubeQuery>,
        ) -> std::result::Result<
            tonic::Response<super::RespGetCubeQuery>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.WorkflowService/getCubeQuery",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.WorkflowService", "getCubeQuery"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod user_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct UserServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> UserServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UserServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            UserServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::EUser>,
        ) -> std::result::Result<tonic::Response<super::EUser>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.UserService/create",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.UserService", "create"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRequest>,
        ) -> std::result::Result<tonic::Response<super::EUser>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/tercen.UserService/get");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.UserService", "get"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::EUser>,
        ) -> std::result::Result<tonic::Response<super::ResponseUpdate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.UserService/update",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.UserService", "update"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::ResponseDelete>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.UserService/delete",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.UserService", "delete"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn connect(
            &mut self,
            request: impl tonic::IntoRequest<super::ReqConnect>,
        ) -> std::result::Result<tonic::Response<super::RespConnect>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.UserService/connect",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.UserService", "connect"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn connect2(
            &mut self,
            request: impl tonic::IntoRequest<super::ReqConnect2>,
        ) -> std::result::Result<tonic::Response<super::RespConnect2>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.UserService/connect2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.UserService", "connect2"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_server_version(
            &mut self,
            request: impl tonic::IntoRequest<super::ReqGetServerVersion>,
        ) -> std::result::Result<
            tonic::Response<super::RespGetServerVersion>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.UserService/getServerVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.UserService", "getServerVersion"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod team_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct TeamServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> TeamServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TeamServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            TeamServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::ETeam>,
        ) -> std::result::Result<tonic::Response<super::ETeam>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TeamService/create",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.TeamService", "create"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRequest>,
        ) -> std::result::Result<tonic::Response<super::ETeam>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/tercen.TeamService/get");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.TeamService", "get"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::ETeam>,
        ) -> std::result::Result<tonic::Response<super::ResponseUpdate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TeamService/update",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.TeamService", "update"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::ResponseDelete>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TeamService/delete",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.TeamService", "delete"));
            self.inner.unary(req, path, codec).await
        }
    }
}
