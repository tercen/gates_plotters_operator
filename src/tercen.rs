// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseUpdate {
    #[prost(string, tag = "1")]
    pub rev: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseDelete {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub rev: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqUpload {
    #[prost(message, optional, tag = "1")]
    pub file: ::core::option::Option<EFileDocument>,
    #[prost(bytes = "vec", tag = "2")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqAppend {
    #[prost(message, optional, tag = "1")]
    pub file: ::core::option::Option<EFileDocument>,
    #[prost(bytes = "vec", tag = "2")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqDownload {
    #[prost(string, tag = "1")]
    pub file_document_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespUpload {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<EFileDocument>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespAppend {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<EFileDocument>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespDownload {
    #[prost(bytes = "vec", tag = "1")]
    pub result: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqStreamTable {
    #[prost(string, tag = "1")]
    pub table_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub cnames: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "3")]
    pub offset: i64,
    #[prost(int64, tag = "4")]
    pub limit: i64,
    #[prost(string, tag = "5")]
    pub binary_format: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespStreamTable {
    #[prost(bytes = "vec", tag = "1")]
    pub result: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqRunTask {
    #[prost(string, tag = "1")]
    pub task_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqCancelTask {
    #[prost(string, tag = "1")]
    pub task_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqWaitDone {
    #[prost(string, tag = "1")]
    pub task_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespRunTask {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespCancelTask {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespWaitDone {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<ETask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqGetCubeQuery {
    #[prost(string, tag = "1")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub step_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespGetCubeQuery {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<CubeQuery>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqConnect {
    #[prost(string, tag = "1")]
    pub username_or_email: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqGetServerVersion {
    #[prost(string, tag = "1")]
    pub module: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespConnect {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<UserSession>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespGetServerVersion {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<Version>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EActivity {
    #[prost(oneof = "e_activity::Object", tags = "1")]
    pub object: ::core::option::Option<e_activity::Object>,
}
/// Nested message and enum types in `EActivity`.
pub mod e_activity {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Activity(super::Activity),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EChart {
    #[prost(oneof = "e_chart::Object", tags = "1, 2, 3, 4, 5, 6")]
    pub object: ::core::option::Option<e_chart::Object>,
}
/// Nested message and enum types in `EChart`.
pub mod e_chart {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Chart(super::Chart),
        #[prost(message, tag = "2")]
        Chartbar(super::ChartBar),
        #[prost(message, tag = "3")]
        Chartheatmap(super::ChartHeatmap),
        #[prost(message, tag = "4")]
        Chartline(super::ChartLine),
        #[prost(message, tag = "5")]
        Chartpoint(super::ChartPoint),
        #[prost(message, tag = "6")]
        Chartsize(super::ChartSize),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EColumnSchema {
    #[prost(oneof = "e_column_schema::Object", tags = "1, 2")]
    pub object: ::core::option::Option<e_column_schema::Object>,
}
/// Nested message and enum types in `EColumnSchema`.
pub mod e_column_schema {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Column(super::Column),
        #[prost(message, tag = "2")]
        Columnschema(super::ColumnSchema),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EDocument {
    #[prost(
        oneof = "e_document::Object",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24"
    )]
    pub object: ::core::option::Option<e_document::Object>,
}
/// Nested message and enum types in `EDocument`.
pub mod e_document {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Computedtableschema(super::ComputedTableSchema),
        #[prost(message, tag = "2")]
        Cubequerytableschema(super::CubeQueryTableSchema),
        #[prost(message, tag = "3")]
        Dockeroperator(super::DockerOperator),
        #[prost(message, tag = "4")]
        Dockerwebappoperator(super::DockerWebAppOperator),
        #[prost(message, tag = "5")]
        Document(super::Document),
        #[prost(message, tag = "6")]
        Filedocument(super::FileDocument),
        #[prost(message, tag = "7")]
        Folderdocument(super::FolderDocument),
        #[prost(message, tag = "8")]
        Gitoperator(super::GitOperator),
        #[prost(message, tag = "9")]
        Operator(super::Operator),
        #[prost(message, tag = "10")]
        Project(super::Project),
        #[prost(message, tag = "11")]
        Projectdocument(super::ProjectDocument),
        #[prost(message, tag = "12")]
        Rlibrary(super::RLibrary),
        #[prost(message, tag = "13")]
        Roperator(super::ROperator),
        #[prost(message, tag = "14")]
        Rsourcelibrary(super::RSourceLibrary),
        #[prost(message, tag = "15")]
        Renvinstalledlibrary(super::RenvInstalledLibrary),
        #[prost(message, tag = "16")]
        Schema(super::Schema),
        #[prost(message, tag = "17")]
        Shinyoperator(super::ShinyOperator),
        #[prost(message, tag = "18")]
        Subscriptionplan(super::SubscriptionPlan),
        #[prost(message, tag = "19")]
        Tableschema(super::TableSchema),
        #[prost(message, tag = "20")]
        Team(super::Team),
        #[prost(message, tag = "21")]
        User(super::User),
        #[prost(message, tag = "22")]
        Webappoperator(super::WebAppOperator),
        #[prost(message, tag = "23")]
        Workerendpoint(super::WorkerEndpoint),
        #[prost(message, tag = "24")]
        Workflow(super::Workflow),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EEvent {
    #[prost(oneof = "e_event::Object", tags = "1, 2, 3, 4, 5, 6, 7, 8")]
    pub object: ::core::option::Option<e_event::Object>,
}
/// Nested message and enum types in `EEvent`.
pub mod e_event {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Event(super::Event),
        #[prost(message, tag = "2")]
        Genericevent(super::GenericEvent),
        #[prost(message, tag = "3")]
        Patchrecords(super::PatchRecords),
        #[prost(message, tag = "4")]
        Taskdataevent(super::TaskDataEvent),
        #[prost(message, tag = "5")]
        Taskevent(super::TaskEvent),
        #[prost(message, tag = "6")]
        Tasklogevent(super::TaskLogEvent),
        #[prost(message, tag = "7")]
        Taskprogressevent(super::TaskProgressEvent),
        #[prost(message, tag = "8")]
        Taskstateevent(super::TaskStateEvent),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EFileDocument {
    #[prost(oneof = "e_file_document::Object", tags = "1")]
    pub object: ::core::option::Option<e_file_document::Object>,
}
/// Nested message and enum types in `EFileDocument`.
pub mod e_file_document {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Filedocument(super::FileDocument),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EFileMetadata {
    #[prost(oneof = "e_file_metadata::Object", tags = "1, 2")]
    pub object: ::core::option::Option<e_file_metadata::Object>,
}
/// Nested message and enum types in `EFileMetadata`.
pub mod e_file_metadata {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Csvfilemetadata(super::CsvFileMetadata),
        #[prost(message, tag = "2")]
        Filemetadata(super::FileMetadata),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EFilterTopExpr {
    #[prost(oneof = "e_filter_top_expr::Object", tags = "1, 2, 3, 4, 5")]
    pub object: ::core::option::Option<e_filter_top_expr::Object>,
}
/// Nested message and enum types in `EFilterTopExpr`.
pub mod e_filter_top_expr {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Filter(super::Filter),
        #[prost(message, tag = "2")]
        Filterexpr(super::FilterExpr),
        #[prost(message, tag = "3")]
        Filterexpr2d(super::FilterExpr2d),
        #[prost(message, tag = "4")]
        Filtertopexpr(super::FilterTopExpr),
        #[prost(message, tag = "5")]
        Namedfilter(super::NamedFilter),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EFolderDocument {
    #[prost(oneof = "e_folder_document::Object", tags = "1")]
    pub object: ::core::option::Option<e_folder_document::Object>,
}
/// Nested message and enum types in `EFolderDocument`.
pub mod e_folder_document {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Folderdocument(super::FolderDocument),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EGarbageObject {
    #[prost(oneof = "e_garbage_object::Object", tags = "1, 2, 3")]
    pub object: ::core::option::Option<e_garbage_object::Object>,
}
/// Nested message and enum types in `EGarbageObject`.
pub mod e_garbage_object {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Garbageobject(super::GarbageObject),
        #[prost(message, tag = "2")]
        Garbagetasks(super::GarbageTasks),
        #[prost(message, tag = "3")]
        Garbagetasks2(super::GarbageTasks2),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ELock {
    #[prost(oneof = "e_lock::Object", tags = "1")]
    pub object: ::core::option::Option<e_lock::Object>,
}
/// Nested message and enum types in `ELock`.
pub mod e_lock {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Lock(super::Lock),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EMetaFactor {
    #[prost(oneof = "e_meta_factor::Object", tags = "1, 2")]
    pub object: ::core::option::Option<e_meta_factor::Object>,
}
/// Nested message and enum types in `EMetaFactor`.
pub mod e_meta_factor {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Mappingfactor(super::MappingFactor),
        #[prost(message, tag = "2")]
        Metafactor(super::MetaFactor),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EOperator {
    #[prost(oneof = "e_operator::Object", tags = "1, 2, 3, 4, 5, 6, 7")]
    pub object: ::core::option::Option<e_operator::Object>,
}
/// Nested message and enum types in `EOperator`.
pub mod e_operator {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Dockeroperator(super::DockerOperator),
        #[prost(message, tag = "2")]
        Dockerwebappoperator(super::DockerWebAppOperator),
        #[prost(message, tag = "3")]
        Gitoperator(super::GitOperator),
        #[prost(message, tag = "4")]
        Operator(super::Operator),
        #[prost(message, tag = "5")]
        Roperator(super::ROperator),
        #[prost(message, tag = "6")]
        Shinyoperator(super::ShinyOperator),
        #[prost(message, tag = "7")]
        Webappoperator(super::WebAppOperator),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EOperatorInputSpec {
    #[prost(oneof = "e_operator_input_spec::Object", tags = "1, 2")]
    pub object: ::core::option::Option<e_operator_input_spec::Object>,
}
/// Nested message and enum types in `EOperatorInputSpec`.
pub mod e_operator_input_spec {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Crosstabspec(super::CrosstabSpec),
        #[prost(message, tag = "2")]
        Operatorinputspec(super::OperatorInputSpec),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EOperatorModel {
    #[prost(oneof = "e_operator_model::Object", tags = "1, 2, 3")]
    pub object: ::core::option::Option<e_operator_model::Object>,
}
/// Nested message and enum types in `EOperatorModel`.
pub mod e_operator_model {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Annotationoperatormodel(super::AnnotationOperatorModel),
        #[prost(message, tag = "2")]
        Gateoperatormodel(super::GateOperatorModel),
        #[prost(message, tag = "3")]
        Operatormodel(super::OperatorModel),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EPalette {
    #[prost(oneof = "e_palette::Object", tags = "1, 2, 3, 4")]
    pub object: ::core::option::Option<e_palette::Object>,
}
/// Nested message and enum types in `EPalette`.
pub mod e_palette {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Categorypalette(super::CategoryPalette),
        #[prost(message, tag = "2")]
        Jetpalette(super::JetPalette),
        #[prost(message, tag = "3")]
        Palette(super::Palette),
        #[prost(message, tag = "4")]
        Ramppalette(super::RampPalette),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EPatchRecords {
    #[prost(oneof = "e_patch_records::Object", tags = "1")]
    pub object: ::core::option::Option<e_patch_records::Object>,
}
/// Nested message and enum types in `EPatchRecords`.
pub mod e_patch_records {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Patchrecords(super::PatchRecords),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EPersistentObject {
    #[prost(
        oneof = "e_persistent_object::Object",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58"
    )]
    pub object: ::core::option::Option<e_persistent_object::Object>,
}
/// Nested message and enum types in `EPersistentObject`.
pub mod e_persistent_object {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Activity(super::Activity),
        #[prost(message, tag = "2")]
        Csvtask(super::CsvTask),
        #[prost(message, tag = "3")]
        Computationtask(super::ComputationTask),
        #[prost(message, tag = "4")]
        Computedtableschema(super::ComputedTableSchema),
        #[prost(message, tag = "5")]
        Creategitoperatortask(super::CreateGitOperatorTask),
        #[prost(message, tag = "6")]
        Cubequerytableschema(super::CubeQueryTableSchema),
        #[prost(message, tag = "7")]
        Cubequerytask(super::CubeQueryTask),
        #[prost(message, tag = "8")]
        Dockeroperator(super::DockerOperator),
        #[prost(message, tag = "9")]
        Dockerwebappoperator(super::DockerWebAppOperator),
        #[prost(message, tag = "10")]
        Document(super::Document),
        #[prost(message, tag = "11")]
        Event(super::Event),
        #[prost(message, tag = "12")]
        Exporttabletask(super::ExportTableTask),
        #[prost(message, tag = "13")]
        Exportworkflowtask(super::ExportWorkflowTask),
        #[prost(message, tag = "14")]
        Filedocument(super::FileDocument),
        #[prost(message, tag = "15")]
        Folderdocument(super::FolderDocument),
        #[prost(message, tag = "16")]
        Garbageobject(super::GarbageObject),
        #[prost(message, tag = "17")]
        Garbagetasks(super::GarbageTasks),
        #[prost(message, tag = "18")]
        Garbagetasks2(super::GarbageTasks2),
        #[prost(message, tag = "19")]
        Genericevent(super::GenericEvent),
        #[prost(message, tag = "20")]
        Gitoperator(super::GitOperator),
        #[prost(message, tag = "21")]
        Gitprojecttask(super::GitProjectTask),
        #[prost(message, tag = "22")]
        Gltask(super::GlTask),
        #[prost(message, tag = "23")]
        Importgitdatasettask(super::ImportGitDatasetTask),
        #[prost(message, tag = "24")]
        Importgitworkflowtask(super::ImportGitWorkflowTask),
        #[prost(message, tag = "25")]
        Importworkflowtask(super::ImportWorkflowTask),
        #[prost(message, tag = "26")]
        Librarytask(super::LibraryTask),
        #[prost(message, tag = "27")]
        Lock(super::Lock),
        #[prost(message, tag = "28")]
        Operator(super::Operator),
        #[prost(message, tag = "29")]
        Patchrecords(super::PatchRecords),
        #[prost(message, tag = "30")]
        Persistentobject(super::PersistentObject),
        #[prost(message, tag = "31")]
        Project(super::Project),
        #[prost(message, tag = "32")]
        Projectdocument(super::ProjectDocument),
        #[prost(message, tag = "33")]
        Projecttask(super::ProjectTask),
        #[prost(message, tag = "34")]
        Rlibrary(super::RLibrary),
        #[prost(message, tag = "35")]
        Roperator(super::ROperator),
        #[prost(message, tag = "36")]
        Rsourcelibrary(super::RSourceLibrary),
        #[prost(message, tag = "37")]
        Renvinstalledlibrary(super::RenvInstalledLibrary),
        #[prost(message, tag = "38")]
        Runcomputationtask(super::RunComputationTask),
        #[prost(message, tag = "39")]
        Runwebapptask(super::RunWebAppTask),
        #[prost(message, tag = "40")]
        Runworkflowtask(super::RunWorkflowTask),
        #[prost(message, tag = "41")]
        Savecomputationresulttask(super::SaveComputationResultTask),
        #[prost(message, tag = "42")]
        Schema(super::Schema),
        #[prost(message, tag = "43")]
        Shinyoperator(super::ShinyOperator),
        #[prost(message, tag = "44")]
        Subscriptionplan(super::SubscriptionPlan),
        #[prost(message, tag = "45")]
        Tableschema(super::TableSchema),
        #[prost(message, tag = "46")]
        Task(super::Task),
        #[prost(message, tag = "47")]
        Taskdataevent(super::TaskDataEvent),
        #[prost(message, tag = "48")]
        Taskevent(super::TaskEvent),
        #[prost(message, tag = "49")]
        Tasklogevent(super::TaskLogEvent),
        #[prost(message, tag = "50")]
        Taskprogressevent(super::TaskProgressEvent),
        #[prost(message, tag = "51")]
        Taskstateevent(super::TaskStateEvent),
        #[prost(message, tag = "52")]
        Team(super::Team),
        #[prost(message, tag = "53")]
        Testoperatortask(super::TestOperatorTask),
        #[prost(message, tag = "54")]
        User(super::User),
        #[prost(message, tag = "55")]
        Usersecret(super::UserSecret),
        #[prost(message, tag = "56")]
        Webappoperator(super::WebAppOperator),
        #[prost(message, tag = "57")]
        Workerendpoint(super::WorkerEndpoint),
        #[prost(message, tag = "58")]
        Workflow(super::Workflow),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EProject {
    #[prost(oneof = "e_project::Object", tags = "1")]
    pub object: ::core::option::Option<e_project::Object>,
}
/// Nested message and enum types in `EProject`.
pub mod e_project {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Project(super::Project),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EProjectDocument {
    #[prost(oneof = "e_project_document::Object", tags = "1, 2, 3, 4, 5, 6, 7, 8")]
    pub object: ::core::option::Option<e_project_document::Object>,
}
/// Nested message and enum types in `EProjectDocument`.
pub mod e_project_document {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Computedtableschema(super::ComputedTableSchema),
        #[prost(message, tag = "2")]
        Cubequerytableschema(super::CubeQueryTableSchema),
        #[prost(message, tag = "3")]
        Filedocument(super::FileDocument),
        #[prost(message, tag = "4")]
        Folderdocument(super::FolderDocument),
        #[prost(message, tag = "5")]
        Projectdocument(super::ProjectDocument),
        #[prost(message, tag = "6")]
        Schema(super::Schema),
        #[prost(message, tag = "7")]
        Tableschema(super::TableSchema),
        #[prost(message, tag = "8")]
        Workflow(super::Workflow),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EProperty {
    #[prost(oneof = "e_property::Object", tags = "1, 2, 3, 4, 5, 6, 7")]
    pub object: ::core::option::Option<e_property::Object>,
}
/// Nested message and enum types in `EProperty`.
pub mod e_property {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Booleanproperty(super::BooleanProperty),
        #[prost(message, tag = "2")]
        Doubleproperty(super::DoubleProperty),
        #[prost(message, tag = "3")]
        Enumeratedproperty(super::EnumeratedProperty),
        #[prost(message, tag = "4")]
        Factorsproperty(super::FactorsProperty),
        #[prost(message, tag = "5")]
        Formulaproperty(super::FormulaProperty),
        #[prost(message, tag = "6")]
        Property(super::Property),
        #[prost(message, tag = "7")]
        Stringproperty(super::StringProperty),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErLibrary {
    #[prost(oneof = "er_library::Object", tags = "1, 2, 3")]
    pub object: ::core::option::Option<er_library::Object>,
}
/// Nested message and enum types in `ERLibrary`.
pub mod er_library {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Rlibrary(super::RLibrary),
        #[prost(message, tag = "2")]
        Rsourcelibrary(super::RSourceLibrary),
        #[prost(message, tag = "3")]
        Renvinstalledlibrary(super::RenvInstalledLibrary),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ERelation {
    #[prost(
        oneof = "e_relation::Object",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12"
    )]
    pub object: ::core::option::Option<e_relation::Object>,
}
/// Nested message and enum types in `ERelation`.
pub mod e_relation {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Compositerelation(::prost::alloc::boxed::Box<super::CompositeRelation>),
        #[prost(message, tag = "2")]
        Distinctrelation(::prost::alloc::boxed::Box<super::DistinctRelation>),
        #[prost(message, tag = "3")]
        Gatherrelation(::prost::alloc::boxed::Box<super::GatherRelation>),
        #[prost(message, tag = "4")]
        Groupbyrelation(::prost::alloc::boxed::Box<super::GroupByRelation>),
        #[prost(message, tag = "5")]
        Inmemoryrelation(super::InMemoryRelation),
        #[prost(message, tag = "6")]
        Referencerelation(::prost::alloc::boxed::Box<super::ReferenceRelation>),
        #[prost(message, tag = "7")]
        Relation(super::Relation),
        #[prost(message, tag = "8")]
        Renamerelation(::prost::alloc::boxed::Box<super::RenameRelation>),
        #[prost(message, tag = "9")]
        Simplerelation(super::SimpleRelation),
        #[prost(message, tag = "10")]
        Tablerelation(super::TableRelation),
        #[prost(message, tag = "11")]
        Unionrelation(super::UnionRelation),
        #[prost(message, tag = "12")]
        Whererelation(::prost::alloc::boxed::Box<super::WhereRelation>),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ESchema {
    #[prost(oneof = "e_schema::Object", tags = "1, 2, 3, 4")]
    pub object: ::core::option::Option<e_schema::Object>,
}
/// Nested message and enum types in `ESchema`.
pub mod e_schema {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Computedtableschema(super::ComputedTableSchema),
        #[prost(message, tag = "2")]
        Cubequerytableschema(super::CubeQueryTableSchema),
        #[prost(message, tag = "3")]
        Schema(super::Schema),
        #[prost(message, tag = "4")]
        Tableschema(super::TableSchema),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EState {
    #[prost(oneof = "e_state::Object", tags = "1, 2, 3, 4, 5, 6, 7, 8")]
    pub object: ::core::option::Option<e_state::Object>,
}
/// Nested message and enum types in `EState`.
pub mod e_state {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Canceledstate(super::CanceledState),
        #[prost(message, tag = "2")]
        Donestate(super::DoneState),
        #[prost(message, tag = "3")]
        Failedstate(super::FailedState),
        #[prost(message, tag = "4")]
        Initstate(super::InitState),
        #[prost(message, tag = "5")]
        Pendingstate(super::PendingState),
        #[prost(message, tag = "6")]
        Runningdependentstate(super::RunningDependentState),
        #[prost(message, tag = "7")]
        Runningstate(super::RunningState),
        #[prost(message, tag = "8")]
        State(super::State),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EStep {
    #[prost(
        oneof = "e_step::Object",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15"
    )]
    pub object: ::core::option::Option<e_step::Object>,
}
/// Nested message and enum types in `EStep`.
pub mod e_step {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Crosstabstep(super::CrossTabStep),
        #[prost(message, tag = "2")]
        Datastep(super::DataStep),
        #[prost(message, tag = "3")]
        Exportstep(super::ExportStep),
        #[prost(message, tag = "4")]
        Groupstep(super::GroupStep),
        #[prost(message, tag = "5")]
        Instep(super::InStep),
        #[prost(message, tag = "6")]
        Joinstep(super::JoinStep),
        #[prost(message, tag = "7")]
        Meltstep(super::MeltStep),
        #[prost(message, tag = "8")]
        Modelstep(super::ModelStep),
        #[prost(message, tag = "9")]
        Namespacestep(super::NamespaceStep),
        #[prost(message, tag = "10")]
        Outstep(super::OutStep),
        #[prost(message, tag = "11")]
        Relationstep(super::RelationStep),
        #[prost(message, tag = "12")]
        Step(super::Step),
        #[prost(message, tag = "13")]
        Tablestep(super::TableStep),
        #[prost(message, tag = "14")]
        Viewstep(super::ViewStep),
        #[prost(message, tag = "15")]
        Wizardstep(super::WizardStep),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ESubscriptionPlan {
    #[prost(oneof = "e_subscription_plan::Object", tags = "1")]
    pub object: ::core::option::Option<e_subscription_plan::Object>,
}
/// Nested message and enum types in `ESubscriptionPlan`.
pub mod e_subscription_plan {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Subscriptionplan(super::SubscriptionPlan),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ETask {
    #[prost(
        oneof = "e_task::Object",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19"
    )]
    pub object: ::core::option::Option<e_task::Object>,
}
/// Nested message and enum types in `ETask`.
pub mod e_task {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Csvtask(super::CsvTask),
        #[prost(message, tag = "2")]
        Computationtask(super::ComputationTask),
        #[prost(message, tag = "3")]
        Creategitoperatortask(super::CreateGitOperatorTask),
        #[prost(message, tag = "4")]
        Cubequerytask(super::CubeQueryTask),
        #[prost(message, tag = "5")]
        Exporttabletask(super::ExportTableTask),
        #[prost(message, tag = "6")]
        Exportworkflowtask(super::ExportWorkflowTask),
        #[prost(message, tag = "7")]
        Gitprojecttask(super::GitProjectTask),
        #[prost(message, tag = "8")]
        Gltask(super::GlTask),
        #[prost(message, tag = "9")]
        Importgitdatasettask(super::ImportGitDatasetTask),
        #[prost(message, tag = "10")]
        Importgitworkflowtask(super::ImportGitWorkflowTask),
        #[prost(message, tag = "11")]
        Importworkflowtask(super::ImportWorkflowTask),
        #[prost(message, tag = "12")]
        Librarytask(super::LibraryTask),
        #[prost(message, tag = "13")]
        Projecttask(super::ProjectTask),
        #[prost(message, tag = "14")]
        Runcomputationtask(super::RunComputationTask),
        #[prost(message, tag = "15")]
        Runwebapptask(super::RunWebAppTask),
        #[prost(message, tag = "16")]
        Runworkflowtask(super::RunWorkflowTask),
        #[prost(message, tag = "17")]
        Savecomputationresulttask(super::SaveComputationResultTask),
        #[prost(message, tag = "18")]
        Task(super::Task),
        #[prost(message, tag = "19")]
        Testoperatortask(super::TestOperatorTask),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ETeam {
    #[prost(oneof = "e_team::Object", tags = "1")]
    pub object: ::core::option::Option<e_team::Object>,
}
/// Nested message and enum types in `ETeam`.
pub mod e_team {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Team(super::Team),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EUser {
    #[prost(oneof = "e_user::Object", tags = "1, 2")]
    pub object: ::core::option::Option<e_user::Object>,
}
/// Nested message and enum types in `EUser`.
pub mod e_user {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Team(super::Team),
        #[prost(message, tag = "2")]
        User(super::User),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EUserSecret {
    #[prost(oneof = "e_user_secret::Object", tags = "1")]
    pub object: ::core::option::Option<e_user_secret::Object>,
}
/// Nested message and enum types in `EUserSecret`.
pub mod e_user_secret {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Usersecret(super::UserSecret),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EWorkflow {
    #[prost(oneof = "e_workflow::Object", tags = "1")]
    pub object: ::core::option::Option<e_workflow::Object>,
}
/// Nested message and enum types in `EWorkflow`.
pub mod e_workflow {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Object {
        #[prost(message, tag = "1")]
        Workflow(super::Workflow),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ace {
    #[prost(message, repeated, tag = "1")]
    pub principals: ::prost::alloc::vec::Vec<Principal>,
    #[prost(message, repeated, tag = "2")]
    pub privileges: ::prost::alloc::vec::Vec<Privilege>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Acl {
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub aces: ::prost::alloc::vec::Vec<Ace>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AclContext {
    #[prost(string, tag = "1")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub domain: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Activity {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub object_kind: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub team_id: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub project_name: ::prost::alloc::string::String,
    #[prost(bool, tag = "10")]
    pub is_public: bool,
    #[prost(message, optional, tag = "11")]
    pub date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "12")]
    pub properties: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityCount {
    #[prost(string, tag = "1")]
    pub object_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Address {
    #[prost(string, tag = "1")]
    pub country: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub state: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub city: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub zip_code: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub address1: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub address2: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub phone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotationModel {
    #[prost(string, tag = "1")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub factors: ::prost::alloc::vec::Vec<GraphicalFactor>,
    #[prost(message, repeated, tag = "3")]
    pub annotation_factors: ::prost::alloc::vec::Vec<GraphicalFactor>,
    #[prost(message, optional, tag = "4")]
    pub relation: ::core::option::Option<ERelation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotationOperatorModel {
    #[prost(message, optional, tag = "1")]
    pub filters: ::core::option::Option<Filters>,
    #[prost(message, repeated, tag = "2")]
    pub annotation_models: ::prost::alloc::vec::Vec<AnnotationModel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiCallProfile {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub n_calls: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppDesign {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub factors: ::prost::alloc::vec::Vec<MappingFactor>,
    #[prost(message, repeated, tag = "6")]
    pub filters: ::prost::alloc::vec::Vec<MappingFilter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Attribute {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Axis {
    #[prost(message, optional, tag = "1")]
    pub axis_extent: ::core::option::Option<Point>,
    #[prost(message, optional, tag = "2")]
    pub axis_settings: ::core::option::Option<AxisSettings>,
    #[prost(message, optional, tag = "3")]
    pub graphical_factor: ::core::option::Option<GraphicalFactor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AxisSettings {
    #[prost(message, repeated, tag = "1")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AxisSpec {
    #[prost(message, repeated, tag = "1")]
    pub meta_factors: ::prost::alloc::vec::Vec<EMetaFactor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BillingInfo {
    #[prost(string, tag = "1")]
    pub first_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub last_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub company_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub tax_id: ::core::option::Option<TaxId>,
    #[prost(message, optional, tag = "5")]
    pub address: ::core::option::Option<Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BooleanProperty {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub default_value: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvFileMetadata {
    #[prost(string, tag = "1")]
    pub content_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub cache_control: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub content_encoding: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub content_language: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub md5_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub separator: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub quote: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub headers: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvParserParam {
    #[prost(string, tag = "1")]
    pub separator: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub encoding: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub quote: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub has_headers: bool,
    #[prost(bool, tag = "5")]
    pub allow_malformed: bool,
    #[prost(string, tag = "6")]
    pub comment: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvTask {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub duration: f64,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub file_document_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub schema_id: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub value_name: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub variable_name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "13")]
    pub gather_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "14")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "15")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "16")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "17")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "18")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "19")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "20")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "21")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "22")]
    pub schema: ::core::option::Option<ESchema>,
    #[prost(message, optional, tag = "23")]
    pub params: ::core::option::Option<CsvParserParam>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CanceledState {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CategoryPalette {
    #[prost(int32, tag = "1")]
    pub backcolor: i32,
    #[prost(message, repeated, tag = "2")]
    pub properties: ::prost::alloc::vec::Vec<PropertyValue>,
    #[prost(message, optional, tag = "3")]
    pub color_list: ::core::option::Option<ColorList>,
    #[prost(message, repeated, tag = "4")]
    pub string_color_elements: ::prost::alloc::vec::Vec<StringColorElement>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Chart {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<Properties>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChartBar {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<Properties>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChartHeatmap {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<Properties>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChartLine {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub point_size: i32,
    #[prost(message, optional, tag = "3")]
    pub properties: ::core::option::Option<Properties>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChartPoint {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub point_size: i32,
    #[prost(message, optional, tag = "3")]
    pub properties: ::core::option::Option<Properties>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChartSize {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub point_size: i32,
    #[prost(message, optional, tag = "3")]
    pub properties: ::core::option::Option<Properties>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColorElement {
    #[prost(int32, tag = "1")]
    pub color: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColorList {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Colors {
    #[prost(message, repeated, tag = "1")]
    pub factors: ::prost::alloc::vec::Vec<Factor>,
    #[prost(message, optional, tag = "2")]
    pub palette: ::core::option::Option<EPalette>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Column {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub n_rows: i32,
    #[prost(int32, tag = "5")]
    pub size: i32,
    #[prost(bytes = "vec", tag = "6")]
    pub values: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "7")]
    pub meta_data: ::core::option::Option<ColumnSchemaMetaData>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnPair {
    #[prost(string, repeated, tag = "1")]
    pub l_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub r_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnSchema {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub n_rows: i32,
    #[prost(int32, tag = "5")]
    pub size: i32,
    #[prost(message, optional, tag = "6")]
    pub meta_data: ::core::option::Option<ColumnSchemaMetaData>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnSchemaMetaData {
    #[prost(string, repeated, tag = "1")]
    pub sort: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "2")]
    pub ascending: bool,
    #[prost(string, repeated, tag = "3")]
    pub quartiles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "4")]
    pub properties: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompositeRelation {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub join_operators: ::prost::alloc::vec::Vec<JoinOperator>,
    #[prost(message, optional, boxed, tag = "3")]
    pub main_relation: ::core::option::Option<::prost::alloc::boxed::Box<ERelation>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputationTask {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub duration: f64,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "9")]
    pub remove_on_gc: bool,
    #[prost(string, repeated, tag = "10")]
    pub schema_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "11")]
    pub parent_task_id: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub file_result_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "13")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "14")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "15")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "16")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "17")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "18")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "19")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "20")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "21")]
    pub query: ::core::option::Option<CubeQuery>,
    #[prost(message, optional, tag = "22")]
    pub computed_relation: ::core::option::Option<ERelation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputedTableSchema {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(string, tag = "9")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub folder_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "11")]
    pub n_rows: i32,
    #[prost(string, tag = "12")]
    pub data_directory: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "13")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "14")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "15")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "16")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "17")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "18")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "19")]
    pub columns: ::prost::alloc::vec::Vec<EColumnSchema>,
    #[prost(message, optional, tag = "20")]
    pub relation: ::core::option::Option<ERelation>,
    #[prost(message, optional, tag = "21")]
    pub query: ::core::option::Option<CubeQuery>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CpuTimeProfile {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(double, tag = "2")]
    pub cpu_time: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateGitOperatorTask {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub duration: f64,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub operator_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub git_token: ::prost::alloc::string::String,
    #[prost(bool, tag = "11")]
    pub test_required: bool,
    #[prost(message, repeated, tag = "12")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "13")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "14")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "15")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "16")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "17")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "18")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "19")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "20")]
    pub url: ::core::option::Option<Url>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrossTabStep {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "6")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "7")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "8")]
    pub state: ::core::option::Option<StepState>,
    #[prost(message, optional, tag = "9")]
    pub model: ::core::option::Option<Crosstab>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Crosstab {
    #[prost(string, tag = "1")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub axis: ::core::option::Option<XyAxisList>,
    #[prost(message, optional, tag = "3")]
    pub column_table: ::core::option::Option<CrosstabTable>,
    #[prost(message, optional, tag = "4")]
    pub filters: ::core::option::Option<Filters>,
    #[prost(message, optional, tag = "5")]
    pub operator_settings: ::core::option::Option<OperatorSettings>,
    #[prost(message, optional, tag = "6")]
    pub row_table: ::core::option::Option<CrosstabTable>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrosstabSpec {
    #[prost(message, repeated, tag = "1")]
    pub meta_factors: ::prost::alloc::vec::Vec<EMetaFactor>,
    #[prost(message, repeated, tag = "2")]
    pub axis: ::prost::alloc::vec::Vec<AxisSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrosstabTable {
    #[prost(double, tag = "1")]
    pub cell_size: f64,
    #[prost(int32, tag = "2")]
    pub offset: i32,
    #[prost(int32, tag = "3")]
    pub n_rows: i32,
    #[prost(message, repeated, tag = "4")]
    pub graphical_factors: ::prost::alloc::vec::Vec<GraphicalFactor>,
    #[prost(message, repeated, tag = "5")]
    pub rectangle_selections: ::prost::alloc::vec::Vec<Rectangle>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CubeAxisQuery {
    #[prost(int32, tag = "1")]
    pub point_size: i32,
    #[prost(string, tag = "2")]
    pub chart_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub y_axis: ::core::option::Option<Factor>,
    #[prost(message, optional, tag = "4")]
    pub y_axis_settings: ::core::option::Option<AxisSettings>,
    #[prost(message, optional, tag = "5")]
    pub x_axis: ::core::option::Option<Factor>,
    #[prost(message, optional, tag = "6")]
    pub x_axis_settings: ::core::option::Option<AxisSettings>,
    #[prost(message, repeated, tag = "7")]
    pub errors: ::prost::alloc::vec::Vec<Factor>,
    #[prost(message, repeated, tag = "8")]
    pub labels: ::prost::alloc::vec::Vec<Factor>,
    #[prost(message, repeated, tag = "9")]
    pub colors: ::prost::alloc::vec::Vec<Factor>,
    #[prost(message, repeated, tag = "10")]
    pub preprocessors: ::prost::alloc::vec::Vec<PreProcessor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CubeQuery {
    #[prost(string, tag = "1")]
    pub qt_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub column_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub row_hash: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub relation: ::core::option::Option<ERelation>,
    #[prost(message, repeated, tag = "5")]
    pub col_columns: ::prost::alloc::vec::Vec<Factor>,
    #[prost(message, repeated, tag = "6")]
    pub row_columns: ::prost::alloc::vec::Vec<Factor>,
    #[prost(message, repeated, tag = "7")]
    pub axis_queries: ::prost::alloc::vec::Vec<CubeAxisQuery>,
    #[prost(message, optional, tag = "8")]
    pub filters: ::core::option::Option<Filters>,
    #[prost(message, optional, tag = "9")]
    pub operator_settings: ::core::option::Option<OperatorSettings>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CubeQueryTableSchema {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(string, tag = "9")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub folder_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "11")]
    pub n_rows: i32,
    #[prost(string, tag = "12")]
    pub data_directory: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub query_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub query_table_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "15")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "16")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "17")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "18")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "19")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "20")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "21")]
    pub columns: ::prost::alloc::vec::Vec<EColumnSchema>,
    #[prost(message, optional, tag = "22")]
    pub relation: ::core::option::Option<ERelation>,
    #[prost(message, optional, tag = "23")]
    pub query: ::core::option::Option<CubeQuery>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CubeQueryTask {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub duration: f64,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "9")]
    pub remove_on_gc: bool,
    #[prost(string, repeated, tag = "10")]
    pub schema_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "11")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "12")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "13")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "14")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "15")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "16")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "17")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "18")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "19")]
    pub query: ::core::option::Option<CubeQuery>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataStep {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub parent_data_step_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "7")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "8")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "9")]
    pub state: ::core::option::Option<StepState>,
    #[prost(message, optional, tag = "10")]
    pub model: ::core::option::Option<Crosstab>,
    #[prost(message, optional, tag = "11")]
    pub computed_relation: ::core::option::Option<ERelation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Date {
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DistinctRelation {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub group: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, boxed, tag = "3")]
    pub relation: ::core::option::Option<::prost::alloc::boxed::Box<ERelation>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DockerOperator {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(string, tag = "9")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub container: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "11")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "12")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "13")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "14")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "15")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "16")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "17")]
    pub properties: ::prost::alloc::vec::Vec<EProperty>,
    #[prost(message, optional, tag = "18")]
    pub operator_spec: ::core::option::Option<OperatorSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DockerWebAppOperator {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(string, tag = "9")]
    pub path: ::prost::alloc::string::String,
    #[prost(bool, tag = "10")]
    pub is_view_only: bool,
    #[prost(string, tag = "11")]
    pub container: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "12")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "13")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "14")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "15")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "16")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "17")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "18")]
    pub properties: ::prost::alloc::vec::Vec<EProperty>,
    #[prost(message, optional, tag = "19")]
    pub operator_spec: ::core::option::Option<OperatorSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Document {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(message, optional, tag = "9")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "10")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "11")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "12")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "13")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "14")]
    pub url: ::core::option::Option<Url>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoneState {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoubleColorElement {
    #[prost(int32, tag = "1")]
    pub color: i32,
    #[prost(string, tag = "2")]
    pub string_value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoubleProperty {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(double, tag = "3")]
    pub default_value: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumeratedProperty {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub default_value: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Errors {
    #[prost(message, repeated, tag = "1")]
    pub factors: ::prost::alloc::vec::Vec<Factor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub date: ::core::option::Option<Date>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportModel {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportStep {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "6")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "7")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "8")]
    pub state: ::core::option::Option<StepState>,
    #[prost(message, optional, tag = "9")]
    pub model: ::core::option::Option<ExportModel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportTableTask {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub duration: f64,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub export_name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "10")]
    pub schema_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "11")]
    pub export_type: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub export_to_id: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub export_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "14")]
    pub namespaces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "15")]
    pub exported_schema_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "16")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "17")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "18")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "19")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "20")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "21")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "22")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "23")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportWorkflowTask {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub duration: f64,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub file_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "11")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "12")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "13")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "14")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "15")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "16")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "17")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "18")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Factor {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FactorsProperty {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub default_value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailedState {
    #[prost(string, tag = "1")]
    pub error: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileDocument {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(string, tag = "9")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub folder_id: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub data_uri: ::prost::alloc::string::String,
    #[prost(int32, tag = "12")]
    pub size: i32,
    #[prost(message, optional, tag = "13")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "14")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "15")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "16")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "17")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "18")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "19")]
    pub metadata: ::core::option::Option<EFileMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileMetadata {
    #[prost(string, tag = "1")]
    pub content_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub cache_control: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub content_encoding: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub content_language: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub md5_hash: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Filter {
    #[prost(string, tag = "1")]
    pub logical: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub not: bool,
    #[prost(message, repeated, tag = "3")]
    pub filter_exprs: ::prost::alloc::vec::Vec<EFilterTopExpr>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterExpr {
    #[prost(string, tag = "1")]
    pub filter_op: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub string_value: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub factor: ::core::option::Option<Factor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterExpr2d {
    #[prost(string, tag = "1")]
    pub filter_op: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub string_value: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub factor: ::core::option::Option<Factor>,
    #[prost(message, optional, tag = "4")]
    pub factor2: ::core::option::Option<Factor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterTopExpr {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Filters {
    #[prost(bool, tag = "1")]
    pub remove_na_n: bool,
    #[prost(message, repeated, tag = "2")]
    pub named_filters: ::prost::alloc::vec::Vec<NamedFilter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FolderDocument {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(string, tag = "9")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub folder_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "11")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "12")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "13")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "14")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "15")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "16")]
    pub url: ::core::option::Option<Url>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FormulaProperty {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub default_value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GarbageObject {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GarbageTasks {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub deleted_task_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "6")]
    pub added_task_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "7")]
    pub deleted_step_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GarbageTasks2 {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub date: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub deleted_task_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "7")]
    pub added_task_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "8")]
    pub deleted_step_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GateNode {
    #[prost(string, tag = "1")]
    pub node_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub crosstab: ::core::option::Option<Crosstab>,
    #[prost(message, repeated, tag = "4")]
    pub children: ::prost::alloc::vec::Vec<GateNode>,
    #[prost(message, repeated, tag = "5")]
    pub statistics: ::prost::alloc::vec::Vec<StatisticNode>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GateOperatorModel {
    #[prost(message, repeated, tag = "1")]
    pub roots: ::prost::alloc::vec::Vec<GateNode>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GatherRelation {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub value_name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub variable_name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub value_type: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub gather_type: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "7")]
    pub relation: ::core::option::Option<::prost::alloc::boxed::Box<ERelation>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenericEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub content: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub date: ::core::option::Option<Date>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitOperator {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(string, tag = "9")]
    pub path: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "11")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "12")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "13")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "14")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "15")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "16")]
    pub properties: ::prost::alloc::vec::Vec<EProperty>,
    #[prost(message, optional, tag = "17")]
    pub operator_spec: ::core::option::Option<OperatorSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitProjectTask {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub duration: f64,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "8")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "9")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "10")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "11")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "12")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "13")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "14")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "15")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlTask {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub duration: f64,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub gl_query: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "9")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "10")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "11")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "12")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "13")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "14")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "15")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "16")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphicalFactor {
    #[prost(message, optional, tag = "1")]
    pub factor: ::core::option::Option<Factor>,
    #[prost(message, optional, tag = "2")]
    pub rectangle: ::core::option::Option<Rectangle>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupByRelation {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub group: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, boxed, tag = "3")]
    pub relation: ::core::option::Option<::prost::alloc::boxed::Box<ERelation>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupStep {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub app_id: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub app_name: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "8")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "9")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "10")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "11")]
    pub state: ::core::option::Option<StepState>,
    #[prost(message, optional, tag = "12")]
    pub offset: ::core::option::Option<Point>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdObject {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportGitDatasetTask {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub duration: f64,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub git_token: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub schema_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "12")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "13")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "14")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "15")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "16")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "17")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "18")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "19")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "20")]
    pub url: ::core::option::Option<Url>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportGitWorkflowTask {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub duration: f64,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub file_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub git_token: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "13")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "14")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "15")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "16")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "17")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "18")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "19")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "20")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "21")]
    pub url: ::core::option::Option<Url>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportWorkflowTask {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub duration: f64,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub file_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub git_token: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "12")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "13")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "14")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "15")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "16")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "17")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "18")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "19")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InMemoryRelation {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub in_memory_table: ::core::option::Option<Table>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InStep {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "6")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "7")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "8")]
    pub state: ::core::option::Option<StepState>,
    #[prost(message, optional, tag = "9")]
    pub group_port_position: ::core::option::Option<Point>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitState {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputPort {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub link_type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JetPalette {
    #[prost(int32, tag = "1")]
    pub backcolor: i32,
    #[prost(bool, tag = "2")]
    pub is_user_defined: bool,
    #[prost(message, repeated, tag = "3")]
    pub properties: ::prost::alloc::vec::Vec<PropertyValue>,
    #[prost(message, repeated, tag = "4")]
    pub double_color_elements: ::prost::alloc::vec::Vec<DoubleColorElement>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinOperator {
    #[prost(string, tag = "1")]
    pub join_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub left_pair: ::core::option::Option<ColumnPair>,
    #[prost(message, optional, tag = "3")]
    pub right_relation: ::core::option::Option<ERelation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinStep {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "6")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "7")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "8")]
    pub state: ::core::option::Option<StepState>,
    #[prost(message, optional, tag = "9")]
    pub model: ::core::option::Option<JoinStepModel>,
    #[prost(message, repeated, tag = "10")]
    pub right_attributes: ::prost::alloc::vec::Vec<Attribute>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinStepModel {
    #[prost(string, tag = "1")]
    pub right_prefix: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub join_type: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub left_factors: ::prost::alloc::vec::Vec<Factor>,
    #[prost(message, repeated, tag = "4")]
    pub right_factors: ::prost::alloc::vec::Vec<Factor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Labels {
    #[prost(message, repeated, tag = "1")]
    pub factors: ::prost::alloc::vec::Vec<Factor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LibraryTask {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub duration: f64,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "8")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "9")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "10")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "11")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "12")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "13")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "14")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "15")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Link {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub input_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub output_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Lock {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MappingFactor {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub ontology_mapping: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub crosstab_mapping: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub cardinality: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub factor_name: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_single: bool,
    #[prost(bool, tag = "9")]
    pub is_required: bool,
    #[prost(message, repeated, tag = "10")]
    pub factors: ::prost::alloc::vec::Vec<Factor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MappingFilter {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub is_required: bool,
    #[prost(message, optional, tag = "4")]
    pub named_filter: ::core::option::Option<NamedFilter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MeltStep {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "6")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "7")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "8")]
    pub state: ::core::option::Option<StepState>,
    #[prost(message, optional, tag = "9")]
    pub model: ::core::option::Option<MeltStepModel>,
    #[prost(message, repeated, tag = "10")]
    pub melted_attributes: ::prost::alloc::vec::Vec<Attribute>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MeltStepModel {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub selection_pattern: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub factor_type: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub gather_type: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub factors: ::prost::alloc::vec::Vec<Factor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaFactor {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub ontology_mapping: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub crosstab_mapping: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub cardinality: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "7")]
    pub factors: ::prost::alloc::vec::Vec<Factor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelStep {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "6")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "7")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "8")]
    pub state: ::core::option::Option<StepState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamedFilter {
    #[prost(string, tag = "1")]
    pub logical: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub not: bool,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub filter_exprs: ::prost::alloc::vec::Vec<EFilterTopExpr>,
    #[prost(message, repeated, tag = "5")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamespaceStep {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "6")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "7")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "8")]
    pub state: ::core::option::Option<StepState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Operator {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(message, optional, tag = "9")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "10")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "11")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "12")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "13")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "14")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "15")]
    pub properties: ::prost::alloc::vec::Vec<EProperty>,
    #[prost(message, optional, tag = "16")]
    pub operator_spec: ::core::option::Option<OperatorSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperatorInputSpec {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperatorModel {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperatorOutputSpec {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperatorRef {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub operator_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub operator_kind: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub property_values: ::prost::alloc::vec::Vec<PropertyValue>,
    #[prost(message, optional, tag = "6")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "7")]
    pub operator_spec: ::core::option::Option<OperatorSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperatorResult {
    #[prost(message, repeated, tag = "1")]
    pub tables: ::prost::alloc::vec::Vec<Table>,
    #[prost(message, repeated, tag = "2")]
    pub join_operators: ::prost::alloc::vec::Vec<JoinOperator>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperatorSettings {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub operator_ref: ::core::option::Option<OperatorRef>,
    #[prost(message, repeated, tag = "3")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "4")]
    pub operator_model: ::core::option::Option<EOperatorModel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperatorSpec {
    #[prost(string, tag = "1")]
    pub ontology_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub ontology_version: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub input_specs: ::prost::alloc::vec::Vec<EOperatorInputSpec>,
    #[prost(message, repeated, tag = "4")]
    pub output_specs: ::prost::alloc::vec::Vec<OperatorOutputSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperatorUnitTest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub input_file_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub input_data_uri: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub output_data_uri: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "6")]
    pub columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "7")]
    pub rows: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "8")]
    pub colors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "9")]
    pub labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "10")]
    pub y_axis: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub x_axis: ::prost::alloc::string::String,
    #[prost(double, tag = "12")]
    pub abs_tol: f64,
    #[prost(double, tag = "13")]
    pub rel_tol: f64,
    #[prost(string, tag = "14")]
    pub equality_method: ::prost::alloc::string::String,
    #[prost(double, tag = "15")]
    pub r2: f64,
    #[prost(string, repeated, tag = "16")]
    pub skip_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "17")]
    pub property_values: ::prost::alloc::vec::Vec<PropertyValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutStep {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "6")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "7")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "8")]
    pub state: ::core::option::Option<StepState>,
    #[prost(message, optional, tag = "9")]
    pub group_port_position: ::core::option::Option<Point>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputPort {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub link_type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pair {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Palette {
    #[prost(int32, tag = "1")]
    pub backcolor: i32,
    #[prost(message, repeated, tag = "2")]
    pub properties: ::prost::alloc::vec::Vec<PropertyValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRecord {
    #[prost(string, tag = "1")]
    pub p: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub t: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub d: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRecords {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub u: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub c_i: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub o_i: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub o_r: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub o_k: ::prost::alloc::string::String,
    #[prost(int32, tag = "9")]
    pub s: i32,
    #[prost(message, optional, tag = "10")]
    pub date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "11")]
    pub rs: ::prost::alloc::vec::Vec<PatchRecord>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PendingState {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PersistentObject {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Plan {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub payment_provider_plan_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub descriptions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(double, tag = "5")]
    pub price: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Point {
    #[prost(double, tag = "1")]
    pub x: f64,
    #[prost(double, tag = "2")]
    pub y: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Port {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub link_type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreProcessor {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub operator_ref: ::core::option::Option<OperatorRef>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Principal {
    #[prost(string, tag = "1")]
    pub principal_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Privilege {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Profile {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Profiles {
    #[prost(message, optional, tag = "1")]
    pub api_profile: ::core::option::Option<ApiCallProfile>,
    #[prost(message, optional, tag = "2")]
    pub table_profile: ::core::option::Option<TableProfile>,
    #[prost(message, optional, tag = "3")]
    pub cpu_time_profile: ::core::option::Option<CpuTimeProfile>,
    #[prost(message, optional, tag = "4")]
    pub storage_profile: ::core::option::Option<StorageProfile>,
    #[prost(message, optional, tag = "5")]
    pub run_profile: ::core::option::Option<RunProfile>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Project {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(message, optional, tag = "9")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "10")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "11")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "12")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "13")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "14")]
    pub url: ::core::option::Option<Url>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectDocument {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(string, tag = "9")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub folder_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "11")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "12")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "13")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "14")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "15")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "16")]
    pub url: ::core::option::Option<Url>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectTask {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub duration: f64,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "9")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "10")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "11")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "12")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "13")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "14")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "15")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "16")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Properties {
    #[prost(message, repeated, tag = "1")]
    pub properties: ::prost::alloc::vec::Vec<EProperty>,
    #[prost(message, repeated, tag = "2")]
    pub property_values: ::prost::alloc::vec::Vec<PropertyValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Property {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PropertyValue {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RDescription {
    #[prost(string, tag = "1")]
    pub package: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub depends: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub imports: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub linking_to: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub suggests: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub license: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub md5sum: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub needs_compilation: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RLibrary {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(message, optional, tag = "9")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "10")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "11")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "12")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "13")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "14")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "15")]
    pub r_description: ::core::option::Option<RDescription>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ROperator {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(string, tag = "9")]
    pub path: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "11")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "12")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "13")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "14")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "15")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "16")]
    pub properties: ::prost::alloc::vec::Vec<EProperty>,
    #[prost(message, optional, tag = "17")]
    pub operator_spec: ::core::option::Option<OperatorSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RProxy {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub target_url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RSourceLibrary {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(string, tag = "9")]
    pub file_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "11")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "12")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "13")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "14")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "15")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "16")]
    pub r_description: ::core::option::Option<RDescription>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RampPalette {
    #[prost(int32, tag = "1")]
    pub backcolor: i32,
    #[prost(bool, tag = "2")]
    pub is_user_defined: bool,
    #[prost(message, repeated, tag = "3")]
    pub properties: ::prost::alloc::vec::Vec<PropertyValue>,
    #[prost(message, repeated, tag = "4")]
    pub double_color_elements: ::prost::alloc::vec::Vec<DoubleColorElement>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rectangle {
    #[prost(message, optional, tag = "1")]
    pub extent: ::core::option::Option<Point>,
    #[prost(message, optional, tag = "2")]
    pub top_left: ::core::option::Option<Point>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReferenceRelation {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "2")]
    pub relation: ::core::option::Option<::prost::alloc::boxed::Box<ERelation>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Relation {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelationStep {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "6")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "7")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "8")]
    pub state: ::core::option::Option<StepState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenameRelation {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub in_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub out_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, boxed, tag = "4")]
    pub relation: ::core::option::Option<::prost::alloc::boxed::Box<ERelation>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenvInstalledLibrary {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(string, tag = "9")]
    pub path: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "11")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "12")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "13")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "14")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "15")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "16")]
    pub r_description: ::core::option::Option<RDescription>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceSummary {
    #[prost(double, tag = "1")]
    pub storage: f64,
    #[prost(double, tag = "2")]
    pub used_storage: f64,
    #[prost(double, tag = "3")]
    pub cpu_time: f64,
    #[prost(double, tag = "4")]
    pub used_cpu_time: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunComputationTask {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub duration: f64,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "9")]
    pub remove_on_gc: bool,
    #[prost(string, repeated, tag = "10")]
    pub schema_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "11")]
    pub parent_task_id: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub file_result_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "13")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "14")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "15")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "16")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "17")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "18")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "19")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "20")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "21")]
    pub query: ::core::option::Option<CubeQuery>,
    #[prost(message, optional, tag = "22")]
    pub computed_relation: ::core::option::Option<ERelation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunProfile {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub memory: i32,
    #[prost(int32, tag = "3")]
    pub kernel_memory: i32,
    #[prost(int32, tag = "4")]
    pub blkio_weight: i32,
    #[prost(int32, tag = "5")]
    pub pids_limit: i32,
    #[prost(int32, tag = "6")]
    pub ulimits_nofile: i32,
    #[prost(int32, tag = "7")]
    pub timeout: i32,
    #[prost(string, tag = "8")]
    pub storage_size: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub cpuset_cpus: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunWebAppTask {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub duration: f64,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub operator_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub cube_query_task_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "11")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "12")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "13")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "14")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "15")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "16")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "17")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "18")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "19")]
    pub url: ::core::option::Option<Url>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunWorkflowTask {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub duration: f64,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub workflow_rev: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "11")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "12")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "13")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "14")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "15")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "16")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "17")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "18")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunningDependentState {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunningState {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveComputationResultTask {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub duration: f64,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "9")]
    pub remove_on_gc: bool,
    #[prost(string, repeated, tag = "10")]
    pub schema_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "11")]
    pub parent_task_id: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub file_result_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "13")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "14")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "15")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "16")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "17")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "18")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "19")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "20")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "21")]
    pub query: ::core::option::Option<CubeQuery>,
    #[prost(message, optional, tag = "22")]
    pub computed_relation: ::core::option::Option<ERelation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(string, tag = "9")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub folder_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "11")]
    pub n_rows: i32,
    #[prost(string, tag = "12")]
    pub data_directory: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "13")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "14")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "15")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "16")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "17")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "18")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "19")]
    pub columns: ::prost::alloc::vec::Vec<EColumnSchema>,
    #[prost(message, optional, tag = "20")]
    pub relation: ::core::option::Option<ERelation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResult {
    #[prost(int32, tag = "1")]
    pub total_rows: i32,
    #[prost(string, tag = "2")]
    pub bookmark: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub rows: ::prost::alloc::vec::Vec<EPersistentObject>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShinyOperator {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(string, tag = "9")]
    pub path: ::prost::alloc::string::String,
    #[prost(bool, tag = "10")]
    pub is_view_only: bool,
    #[prost(message, optional, tag = "11")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "12")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "13")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "14")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "15")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "16")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "17")]
    pub properties: ::prost::alloc::vec::Vec<EProperty>,
    #[prost(message, optional, tag = "18")]
    pub operator_spec: ::core::option::Option<OperatorSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimpleRelation {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub index: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartProcess {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub executable: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub arguments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "4")]
    pub timeout: i32,
    #[prost(int32, tag = "5")]
    pub pid: i32,
    #[prost(string, tag = "6")]
    pub script: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub ulimits: ::core::option::Option<Ulimits>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct State {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatisticNode {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Step {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "6")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "7")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "8")]
    pub state: ::core::option::Option<StepState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StepModel {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StepState {
    #[prost(string, tag = "1")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub task_state: ::core::option::Option<EState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageProfile {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringColorElement {
    #[prost(int32, tag = "1")]
    pub color: i32,
    #[prost(string, tag = "2")]
    pub string_value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringProperty {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub default_value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscriptionPlan {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(string, tag = "9")]
    pub provider_key: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub payment_provider_plan_id: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub checkout_session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub subscription_id: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub status: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub payment_method_status: ::prost::alloc::string::String,
    #[prost(string, tag = "15")]
    pub ip: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "16")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "17")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "18")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "19")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "20")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "21")]
    pub url: ::core::option::Option<Url>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Summary {
    #[prost(message, optional, tag = "1")]
    pub table_summary: ::core::option::Option<TableSummary>,
    #[prost(message, optional, tag = "2")]
    pub computed_table_summary: ::core::option::Option<TableSummary>,
    #[prost(message, optional, tag = "3")]
    pub query_table_summary: ::core::option::Option<TableSummary>,
    #[prost(message, optional, tag = "4")]
    pub task_summary: ::core::option::Option<TaskSummary>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Table {
    #[prost(int32, tag = "1")]
    pub n_rows: i32,
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<TableProperties>,
    #[prost(message, repeated, tag = "3")]
    pub columns: ::prost::alloc::vec::Vec<Column>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableProfile {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub n_rows: i32,
    #[prost(int32, tag = "3")]
    pub n_cols: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableProperties {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub sort_order: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "3")]
    pub ascending: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableRelation {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub index: i32,
    #[prost(int32, tag = "3")]
    pub n_rows: i32,
    #[prost(string, tag = "4")]
    pub data_dir: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub meta_data: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, repeated, tag = "6")]
    pub attributes: ::prost::alloc::vec::Vec<Attribute>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableSchema {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(string, tag = "9")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub folder_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "11")]
    pub n_rows: i32,
    #[prost(string, tag = "12")]
    pub data_directory: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "13")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "14")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "15")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "16")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "17")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "18")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "19")]
    pub columns: ::prost::alloc::vec::Vec<EColumnSchema>,
    #[prost(message, optional, tag = "20")]
    pub relation: ::core::option::Option<ERelation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableStep {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "6")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "7")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "8")]
    pub state: ::core::option::Option<StepState>,
    #[prost(message, optional, tag = "9")]
    pub model: ::core::option::Option<TableStepModel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableStepModel {
    #[prost(message, optional, tag = "1")]
    pub relation: ::core::option::Option<ERelation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableSummary {
    #[prost(int32, tag = "1")]
    pub n: i32,
    #[prost(int32, tag = "2")]
    pub size: i32,
    #[prost(int32, tag = "3")]
    pub nr: i32,
    #[prost(int32, tag = "4")]
    pub nc: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Task {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub duration: f64,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "8")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "9")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "10")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "11")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "12")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "13")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "14")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "15")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskDataEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "5")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "6")]
    pub date: ::core::option::Option<Date>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub date: ::core::option::Option<Date>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskLogEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub date: ::core::option::Option<Date>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskProgressEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub message: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub total: i32,
    #[prost(int32, tag = "7")]
    pub actual: i32,
    #[prost(message, optional, tag = "8")]
    pub date: ::core::option::Option<Date>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskStateEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "6")]
    pub state: ::core::option::Option<EState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskSummary {
    #[prost(int32, tag = "1")]
    pub n: i32,
    #[prost(double, tag = "2")]
    pub duration: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaxId {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub is_valid: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Team {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(string, tag = "9")]
    pub email: ::prost::alloc::string::String,
    #[prost(bool, tag = "10")]
    pub is_validated: bool,
    #[prost(string, tag = "11")]
    pub domain: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "12")]
    pub roles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "13")]
    pub invited_by_username: ::prost::alloc::string::String,
    #[prost(int32, tag = "14")]
    pub invitation_counts: i32,
    #[prost(int32, tag = "15")]
    pub max_invitation: i32,
    #[prost(message, optional, tag = "16")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "17")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "18")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "19")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "20")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "21")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "22")]
    pub team_acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "23")]
    pub billing_info: ::core::option::Option<BillingInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestOperatorTask {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub duration: f64,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub task_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub operator_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "10")]
    pub test_required: bool,
    #[prost(message, repeated, tag = "11")]
    pub environment: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "12")]
    pub state: ::core::option::Option<EState>,
    #[prost(message, optional, tag = "13")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "14")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "15")]
    pub run_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "16")]
    pub completed_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "17")]
    pub acl_context: ::core::option::Option<AclContext>,
    #[prost(message, repeated, tag = "18")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Token {
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub token: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub expiry: ::core::option::Option<Date>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ulimits {
    #[prost(int32, tag = "1")]
    pub core_file_size: i32,
    #[prost(int32, tag = "2")]
    pub data_seg_size: i32,
    #[prost(int32, tag = "3")]
    pub scheduling_priority: i32,
    #[prost(int32, tag = "4")]
    pub file_size: i32,
    #[prost(int32, tag = "5")]
    pub pending_signals: i32,
    #[prost(int32, tag = "6")]
    pub max_locked_memory: i32,
    #[prost(int32, tag = "7")]
    pub max_memory_size: i32,
    #[prost(int32, tag = "8")]
    pub open_files: i32,
    #[prost(int32, tag = "9")]
    pub pipe_size: i32,
    #[prost(int32, tag = "10")]
    pub message_queues: i32,
    #[prost(int32, tag = "11")]
    pub real_time_priority: i32,
    #[prost(int32, tag = "12")]
    pub stack_size: i32,
    #[prost(int32, tag = "13")]
    pub cpu_time: i32,
    #[prost(int32, tag = "14")]
    pub max_user_processes: i32,
    #[prost(int32, tag = "15")]
    pub virtual_memory: i32,
    #[prost(int32, tag = "16")]
    pub file_locks: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnionRelation {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub relations: ::prost::alloc::vec::Vec<ERelation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Url {
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(string, tag = "9")]
    pub email: ::prost::alloc::string::String,
    #[prost(bool, tag = "10")]
    pub is_validated: bool,
    #[prost(string, tag = "11")]
    pub domain: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "12")]
    pub roles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "13")]
    pub invited_by_username: ::prost::alloc::string::String,
    #[prost(int32, tag = "14")]
    pub invitation_counts: i32,
    #[prost(int32, tag = "15")]
    pub max_invitation: i32,
    #[prost(message, optional, tag = "16")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "17")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "18")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "19")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "20")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "21")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "22")]
    pub team_acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "23")]
    pub billing_info: ::core::option::Option<BillingInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserSecret {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub salt: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub hash_password: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "7")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserSession {
    #[prost(message, optional, tag = "1")]
    pub server_version: ::core::option::Option<Version>,
    #[prost(message, optional, tag = "2")]
    pub user: ::core::option::Option<EUser>,
    #[prost(message, optional, tag = "3")]
    pub token: ::core::option::Option<Token>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Version {
    #[prost(int32, tag = "1")]
    pub major: i32,
    #[prost(int32, tag = "2")]
    pub minor: i32,
    #[prost(int32, tag = "3")]
    pub patch: i32,
    #[prost(string, tag = "4")]
    pub tag: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub date: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub commit: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "7")]
    pub features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViesInfo {
    #[prost(string, tag = "1")]
    pub country_code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub vat_number: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub request_date: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub valid: bool,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub address: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewStep {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "6")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "7")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "8")]
    pub state: ::core::option::Option<StepState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebAppOperator {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(string, tag = "9")]
    pub path: ::prost::alloc::string::String,
    #[prost(bool, tag = "10")]
    pub is_view_only: bool,
    #[prost(message, optional, tag = "11")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "12")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "13")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "14")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "15")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "16")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "17")]
    pub properties: ::prost::alloc::vec::Vec<EProperty>,
    #[prost(message, optional, tag = "18")]
    pub operator_spec: ::core::option::Option<OperatorSpec>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WhereRelation {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "2")]
    pub relation: ::core::option::Option<::prost::alloc::boxed::Box<ERelation>>,
    #[prost(message, optional, tag = "3")]
    pub filters: ::core::option::Option<Filters>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WizardStep {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub inputs: ::prost::alloc::vec::Vec<InputPort>,
    #[prost(message, repeated, tag = "6")]
    pub outputs: ::prost::alloc::vec::Vec<OutputPort>,
    #[prost(message, optional, tag = "7")]
    pub rectangle: ::core::option::Option<Rectangle>,
    #[prost(message, optional, tag = "8")]
    pub state: ::core::option::Option<StepState>,
    #[prost(message, optional, tag = "9")]
    pub model: ::core::option::Option<WizardStepModel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WizardStepModel {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub app_design_type: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub factors: ::prost::alloc::vec::Vec<MappingFactor>,
    #[prost(message, repeated, tag = "5")]
    pub filters: ::prost::alloc::vec::Vec<MappingFilter>,
    #[prost(message, repeated, tag = "6")]
    pub steps: ::prost::alloc::vec::Vec<EStep>,
    #[prost(message, repeated, tag = "7")]
    pub default_factors: ::prost::alloc::vec::Vec<MappingFactor>,
    #[prost(message, repeated, tag = "8")]
    pub default_filters: ::prost::alloc::vec::Vec<MappingFilter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Worker {
    #[prost(string, tag = "1")]
    pub status: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub priority: f64,
    #[prost(int32, tag = "5")]
    pub n_cpu: i32,
    #[prost(int32, tag = "6")]
    pub n_thread: i32,
    #[prost(double, tag = "7")]
    pub memory: f64,
    #[prost(int32, tag = "8")]
    pub n_available_thread: i32,
    #[prost(double, tag = "9")]
    pub available_memory: f64,
    #[prost(string, repeated, tag = "10")]
    pub available_task_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "11")]
    pub task_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "12")]
    pub last_date_activity: ::prost::alloc::string::String,
    #[prost(int32, tag = "13")]
    pub heart_beat: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerEndpoint {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(string, tag = "9")]
    pub uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "11")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "12")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "13")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "14")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "15")]
    pub url: ::core::option::Option<Url>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Workflow {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_deleted: bool,
    #[prost(string, tag = "3")]
    pub rev: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub is_public: bool,
    #[prost(string, tag = "9")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub folder_id: ::prost::alloc::string::String,
    #[prost(double, tag = "11")]
    pub scale: f64,
    #[prost(message, optional, tag = "12")]
    pub acl: ::core::option::Option<Acl>,
    #[prost(message, optional, tag = "13")]
    pub created_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "14")]
    pub last_modified_date: ::core::option::Option<Date>,
    #[prost(message, repeated, tag = "15")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
    #[prost(message, repeated, tag = "16")]
    pub meta: ::prost::alloc::vec::Vec<Pair>,
    #[prost(message, optional, tag = "17")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, repeated, tag = "18")]
    pub links: ::prost::alloc::vec::Vec<Link>,
    #[prost(message, repeated, tag = "19")]
    pub steps: ::prost::alloc::vec::Vec<EStep>,
    #[prost(message, optional, tag = "20")]
    pub offset: ::core::option::Option<Point>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct XyAxis {
    #[prost(string, tag = "1")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub chart: ::core::option::Option<EChart>,
    #[prost(message, optional, tag = "3")]
    pub colors: ::core::option::Option<Colors>,
    #[prost(message, optional, tag = "4")]
    pub errors: ::core::option::Option<Errors>,
    #[prost(message, optional, tag = "5")]
    pub labels: ::core::option::Option<Labels>,
    #[prost(message, optional, tag = "6")]
    pub x_axis: ::core::option::Option<Axis>,
    #[prost(message, optional, tag = "7")]
    pub y_axis: ::core::option::Option<Axis>,
    #[prost(message, repeated, tag = "8")]
    pub preprocessors: ::prost::alloc::vec::Vec<PreProcessor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct XyAxisList {
    #[prost(message, repeated, tag = "1")]
    pub rectangle_selections: ::prost::alloc::vec::Vec<Rectangle>,
    #[prost(message, repeated, tag = "2")]
    pub xy_axis: ::prost::alloc::vec::Vec<XyAxis>,
}
/// Generated client implementations.
pub mod file_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct FileServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> FileServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> FileServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            FileServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::EFileDocument>,
        ) -> std::result::Result<tonic::Response<super::EFileDocument>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.FileService/create",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.FileService", "create"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRequest>,
        ) -> std::result::Result<tonic::Response<super::EFileDocument>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/tercen.FileService/get");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.FileService", "get"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::EFileDocument>,
        ) -> std::result::Result<tonic::Response<super::ResponseUpdate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.FileService/update",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.FileService", "update"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::ResponseDelete>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.FileService/delete",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.FileService", "delete"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn upload(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::ReqUpload>,
        ) -> std::result::Result<tonic::Response<super::RespUpload>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.FileService/upload",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.FileService", "upload"));
            self.inner.client_streaming(req, path, codec).await
        }
        pub async fn append(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::ReqAppend>,
        ) -> std::result::Result<tonic::Response<super::RespAppend>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.FileService/append",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.FileService", "append"));
            self.inner.client_streaming(req, path, codec).await
        }
        pub async fn download(
            &mut self,
            request: impl tonic::IntoRequest<super::ReqDownload>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::RespDownload>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.FileService/download",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.FileService", "download"));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod folder_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct FolderServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> FolderServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> FolderServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            FolderServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::EFolderDocument>,
        ) -> std::result::Result<
            tonic::Response<super::EFolderDocument>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.FolderService/create",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.FolderService", "create"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EFolderDocument>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/tercen.FolderService/get");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.FolderService", "get"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::EFolderDocument>,
        ) -> std::result::Result<tonic::Response<super::ResponseUpdate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.FolderService/update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.FolderService", "update"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::ResponseDelete>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.FolderService/delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.FolderService", "delete"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod table_schema_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct TableSchemaServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> TableSchemaServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TableSchemaServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            TableSchemaServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::ESchema>,
        ) -> std::result::Result<tonic::Response<super::ESchema>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TableSchemaService/create",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.TableSchemaService", "create"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRequest>,
        ) -> std::result::Result<tonic::Response<super::ESchema>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TableSchemaService/get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.TableSchemaService", "get"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::ESchema>,
        ) -> std::result::Result<tonic::Response<super::ResponseUpdate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TableSchemaService/update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.TableSchemaService", "update"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::ResponseDelete>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TableSchemaService/delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.TableSchemaService", "delete"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn stream_table(
            &mut self,
            request: impl tonic::IntoRequest<super::ReqStreamTable>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::RespStreamTable>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TableSchemaService/streamTable",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.TableSchemaService", "streamTable"));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod task_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct TaskServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> TaskServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TaskServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            TaskServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::ETask>,
        ) -> std::result::Result<tonic::Response<super::ETask>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TaskService/create",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.TaskService", "create"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRequest>,
        ) -> std::result::Result<tonic::Response<super::ETask>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/tercen.TaskService/get");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.TaskService", "get"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::ETask>,
        ) -> std::result::Result<tonic::Response<super::ResponseUpdate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TaskService/update",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.TaskService", "update"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::ResponseDelete>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TaskService/delete",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.TaskService", "delete"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn run_task(
            &mut self,
            request: impl tonic::IntoRequest<super::ReqRunTask>,
        ) -> std::result::Result<tonic::Response<super::RespRunTask>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TaskService/runTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.TaskService", "runTask"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn cancel_task(
            &mut self,
            request: impl tonic::IntoRequest<super::ReqCancelTask>,
        ) -> std::result::Result<tonic::Response<super::RespCancelTask>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TaskService/cancelTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.TaskService", "cancelTask"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn wait_done(
            &mut self,
            request: impl tonic::IntoRequest<super::ReqWaitDone>,
        ) -> std::result::Result<tonic::Response<super::RespWaitDone>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TaskService/waitDone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.TaskService", "waitDone"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod workflow_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct WorkflowServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> WorkflowServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WorkflowServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            WorkflowServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::EWorkflow>,
        ) -> std::result::Result<tonic::Response<super::EWorkflow>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.WorkflowService/create",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.WorkflowService", "create"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRequest>,
        ) -> std::result::Result<tonic::Response<super::EWorkflow>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.WorkflowService/get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.WorkflowService", "get"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::EWorkflow>,
        ) -> std::result::Result<tonic::Response<super::ResponseUpdate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.WorkflowService/update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.WorkflowService", "update"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::ResponseDelete>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.WorkflowService/delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.WorkflowService", "delete"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_cube_query(
            &mut self,
            request: impl tonic::IntoRequest<super::ReqGetCubeQuery>,
        ) -> std::result::Result<
            tonic::Response<super::RespGetCubeQuery>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.WorkflowService/getCubeQuery",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.WorkflowService", "getCubeQuery"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod user_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct UserServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> UserServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UserServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            UserServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::EUser>,
        ) -> std::result::Result<tonic::Response<super::EUser>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.UserService/create",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.UserService", "create"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRequest>,
        ) -> std::result::Result<tonic::Response<super::EUser>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/tercen.UserService/get");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.UserService", "get"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::EUser>,
        ) -> std::result::Result<tonic::Response<super::ResponseUpdate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.UserService/update",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.UserService", "update"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::ResponseDelete>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.UserService/delete",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.UserService", "delete"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn connect(
            &mut self,
            request: impl tonic::IntoRequest<super::ReqConnect>,
        ) -> std::result::Result<tonic::Response<super::RespConnect>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.UserService/connect",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.UserService", "connect"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_server_version(
            &mut self,
            request: impl tonic::IntoRequest<super::ReqGetServerVersion>,
        ) -> std::result::Result<
            tonic::Response<super::RespGetServerVersion>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.UserService/getServerVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tercen.UserService", "getServerVersion"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod team_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct TeamServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> TeamServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TeamServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            TeamServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::ETeam>,
        ) -> std::result::Result<tonic::Response<super::ETeam>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TeamService/create",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.TeamService", "create"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRequest>,
        ) -> std::result::Result<tonic::Response<super::ETeam>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/tercen.TeamService/get");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.TeamService", "get"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::ETeam>,
        ) -> std::result::Result<tonic::Response<super::ResponseUpdate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TeamService/update",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.TeamService", "update"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::ResponseDelete>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tercen.TeamService/delete",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tercen.TeamService", "delete"));
            self.inner.unary(req, path, codec).await
        }
    }
}
